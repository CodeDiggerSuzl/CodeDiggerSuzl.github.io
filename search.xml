<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《数学之美》读书笔记</title>
      <link href="/articles/e9e88f1a.html"/>
      <url>/articles/e9e88f1a.html</url>
      
        <content type="html"><![CDATA[<p>书籍链接：<span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8yNjE2MzQ1NC8=">数学之美 （第二版）<i class="fa fa-external-link-alt"></i></span></p><h2 id="第一章-文字和语言-vs-数字和信息"><a href="#第一章-文字和语言-vs-数字和信息" class="headerlink" title="第一章: 文字和语言 vs 数字和信息"></a>第一章: 文字和语言 vs 数字和信息</h2><h3 id="信息概览"><a href="#信息概览" class="headerlink" title="信息概览"></a>信息概览</h3><p>通信的原理和模型：</p><ul><li>通信的原理：信息的产生、传播、接受、反馈</li><li>信息传播的模型：信息源 –&gt; 编码 –&gt; 信道 –&gt; 解码 –&gt; 接受者</li></ul><p>聚类：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JTgxJTlBJUU3JUIxJUJCJUU1JTg4JTg2JUU2JTlFJTkw">聚类分析 - 维基百科，自由的百科全书<i class="fa fa-external-link-alt"></i></span></li><li>“根据相同的属性将事物聚集在一起”</li></ul><p>（信源）编码和最短编码：</p><ul><li>编码：将物体的外表进化成抽象的概念，本质对应着信息的编码。</li><li>最短编码：“常用字短、生僻字长，经常用的文字笔画少比较简单”</li></ul><p>编码和解码：</p><ul><li>字母到词的构词法是词的编码规则。语法则是语言的编码和解码规则。</li></ul><p>校验位：</p><ul><li>防止信息传输有误采用的方法。犹太学者抄写圣经的时候将每个希伯来字母对应一个数字，最后每一行进行求和在和原书的每一行进行比较，如果和相同则表示抄写无误。</li></ul><p>双语对照文本，语料库和机器翻译：</p><ul><li>Rosetta 上有三种文字记录了同一段诏书。</li></ul><p>多义性和利用上下文消除歧义性：</p><ul><li>同一个字可能表示不同的意思（聚类），可以通过上下文来确定含义。</li></ul><h3 id="段落摘要"><a href="#段落摘要" class="headerlink" title="段落摘要:"></a>段落摘要:</h3><blockquote><p>翻译这件事之所以能够达成,仅仅是因为不同的文字系统在记录信息上的能力是等价的。（这个结论很重要。）进一步讲，文字只是信息的载体，而非信息本身。</p></blockquote><blockquote><p>在通信时，如果信道较宽，信息不必压缩就可以直接传递；如果信道较窄，信息传递前要尽可能的压缩，然后再接收端进行解压缩。在古代，两个人说的快是一个宽信道，无需压缩；书信来得慢是一个窄信道，需要压缩。</p></blockquote><h3 id="有趣的知识"><a href="#有趣的知识" class="headerlink" title="有趣的知识"></a>有趣的知识</h3><ul><li>Rosetta Stone： 一块古埃及石碑，上面有埃及象形文字、埃及拼音文字和古希腊文字三种文字，这三种文字记录了同一件事情：托勒密五世的登基诏书。现在在英国大英博物馆。这也是很多翻译软件叫 Rosetta 的原因。 有趣的是这个名字也是老友记中 Joey 的懒人椅的名字。wiki 链接：<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJFJTg1JUU1JUExJTlFJUU1JUExJTk0JUU3JTlGJUIzJUU3JUEyJTkx">罗塞塔石碑 - 维基百科，自由的百科全书<i class="fa fa-external-link-alt"></i></span></li><li>阿拉伯数字实际上是印度人发明的，通过阿拉伯人传入了欧洲，阿拉伯人只是“二道贩子”。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 自然科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell 脚本编程-1</title>
      <link href="/articles/80fbfe5c.html"/>
      <url>/articles/80fbfe5c.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-shell"><a href="#什么是-shell" class="headerlink" title="什么是 shell ?"></a>什么是 shell ?</h2><p>维基百科定义：</p><blockquote><p>Computers understand the language of zeros and ones known as <span class="exturl" data-url="aHR0cHM6Ly9iYXNoLmN5YmVyY2l0aS5iaXovd2lraS9pbmRleC5waHA/dGl0bGU9QmluYXJ5X2xhbmd1YWdlJmFjdGlvbj1lZGl0JnJlZGxpbms9MQ==">binary language<i class="fa fa-external-link-alt"></i></span>. In the early days of computing, instructions were provided using binary language, which is difficult for all of us to read and write. Therefore, in an operating system there is a special program called the shell. The shell accepts human readable commands and translates them into something the kernel can read and process.</p></blockquote><p>简而言之：shell 就是将人类可读的指令转换成计算机内核能够识别并执行的程序。</p><p>常见的 shell 有:</p><p><img  width = '256' height ='144' src="https://kurume-4th-ranger-club.com/wp-content/uploads/2020/07/bash_logo_eyecatch-1024x576.png" align = "right" hspace="12"></img></p><ul><li>Bourne Shell（sh）</li><li>Bourne Again shell（bash）</li><li>C Shell（csh）</li><li>TENEX C Shell（tcsh）</li><li>Korn shell（ksh）</li><li>Z Shell（zsh）</li><li>Friendly Interactive Shell（fish）</li></ul><p>其中 bash 是目前使用最多的 shell。</p><p><strong>shell 脚本</strong> 就是将完成一个任务的所有的命令按照执行的先后顺序，自上而下写入到一个文本文件中，然后给予执行权限。</p><p>比如：这是一个安装 ngixn 的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#install gcc</span></span><br><span class="line">yum -y install wget gcc pcre-devel zlib-devel</span><br><span class="line"><span class="comment">#get nginx</span></span><br><span class="line">wget http://nginx.org/download/nginx-1.16.0.tar.gz</span><br><span class="line"></span><br><span class="line">tar xf nginx-1.16.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> nginx-1.16.0</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/nginx</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>给脚本赋予权限 <code>chmod 700 ngnix_installation_script.sh</code> 或者 <code>sh nginx_installation_script.sh</code>, 就可以运行了.</p><h2 id="shell-脚本基础"><a href="#shell-脚本基础" class="headerlink" title="shell 脚本基础"></a>shell 脚本基础</h2><h3 id="注释和命名"><a href="#注释和命名" class="headerlink" title="注释和命名"></a>注释和命名</h3><ul><li>shell 中使用 <code>#</code> 进行注释</li><li>脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以 <code>#!</code> 字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。</li><li>shell 脚本文件的命名和其他编程语言的命名类似，数字不能开头，</li></ul><h3 id="运行一个脚本"><a href="#运行一个脚本" class="headerlink" title="运行一个脚本"></a>运行一个脚本</h3><ol><li><p>脚本运行需要执行权限，当我们给一个文件赋予执行权限后，该脚本就可以运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x script_fileName</span><br></pre></td></tr></table></figure></li><li><p>直接使用 bash 进行运行 <code>bash script_fileName</code></p></li></ol><h3 id="shell-中的特殊符号-会被特殊对待"><a href="#shell-中的特殊符号-会被特殊对待" class="headerlink" title="shell 中的特殊符号,(会被特殊对待)"></a>shell 中的特殊符号,(会被特殊对待)</h3><ol><li><code>~</code> 家目录</li><li><code>!</code> 执行历史命令,<code>!!</code> 表示执行上一条命令</li><li><code>$</code> 去变量符号</li><li><code>&amp;</code> 后台执行</li><li><code>*</code> shell 中的通配符号, 匹配所有</li><li><code>?</code> shell 中的通配符号, 匹配除回车外的一个字符</li><li><code>;</code> 多条命令之间的分割符号</li><li><code>|</code> 管道符号</li><li><code>\</code> 转义符号</li><li>&#96; 反引号, 命令中执行命令</li><li><code>&#39;&#39;</code> 单引号, 脚本中字符串需要用单引号括起来,<strong>但是不会解释变量</strong></li><li><code>&quot;&quot;</code> 双引号, 用于包裹字符串</li></ol><h3 id="shell-中的重定向"><a href="#shell-中的重定向" class="headerlink" title="shell 中的重定向"></a>shell 中的重定向</h3><ol><li><p><code>&gt;</code> 重定向输入 覆盖原始的数据</p></li><li><p><code>&gt;&gt;</code> 从定向追加输入, 在原来的文件中追加数据</p></li><li><p><code>&lt;</code> 重定向输出 <code>wc -l &lt; /etc/passwd</code> 统计数据流</p></li><li><p><code>&lt;&lt;</code> 重定向追加输出 <code>fdisk /dev/sdb &lt;</code></p><p> 格式化硬盘，重新缓存。</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">fdisk /dev/sdb &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">n</span></span><br><span class="line"><span class="string">p</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">+534M</span></span><br><span class="line"><span class="string">w</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="shell-中的数学运算"><a href="#shell-中的数学运算" class="headerlink" title="shell 中的数学运算"></a>shell 中的数学运算</h3><ol><li><p><strong>expr</strong> 只能整数运算, 格式比较古板 需要有空格 <code>expr 1 + 1</code></p></li><li><p><strong>bc</strong> 使用 bc 计算器处理浮点运算,<code>scale=2</code> 代表小数点保留两位 <code>echo &quot;scale=2;3+100&quot;|bc</code></p></li><li><p>双小圆括号进行运算 shell 中 <code>(())</code> 可以用来做数学运算 <code>echo $(( 100**3 ))</code></p></li></ol><h3 id="退出脚本"><a href="#退出脚本" class="headerlink" title="退出脚本"></a>退出脚本</h3><p>exit NUM 退出脚本, 释放系统资源 (NUM 代表一个整数) 代表脚本的返回值</p><p>在命令行中输入：<br><code>man exit</code> 查看详细 <code>exit</code> 详细的信息</p><h2 id="输出和输入"><a href="#输出和输入" class="headerlink" title="输出和输入"></a>输出和输入</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><p><code>echo</code> 命令的作用是在屏幕输出一行文本，可以将该命令的参数原样输出。</p><ul><li><p><code>-n</code>: 在文本末尾不添加换行符号</p></li><li><p><code>-e</code>: <strong>解释</strong> 引号中的特殊字符 (双引号和单引号)</p></li><li><p><code>-b</code>: 删除一个符号</p><p>  倒计时脚本:</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> time <span class="keyword">in</span> `<span class="built_in">seq</span> 9 -1 0`;<span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> -ne <span class="string">&quot;\b<span class="variable">$time</span>&quot;</span></span><br><span class="line">        <span class="built_in">sleep</span> 1</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><h4 id="脚本的传参"><a href="#脚本的传参" class="headerlink" title="脚本的传参"></a>脚本的传参</h4><ul><li><p><code>$1</code>: 在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：**<code>$n</code>**。<code>n</code> 代表一个数字，，其中 <code>$0</code> 为执行的文件名（包含文件路径）, <code>$1</code> 为执行脚本的第一个参数，<code>$2 </code> 为执行脚本的第二个参数，以此类推……</p></li><li><p><code>$#</code>:  传递到脚本的参数个数</p></li><li><p><code>$*</code>:  以一个单字符串显示所有向脚本传递的参数。 如 <code>$*</code> 用「”」括起来的情况、以 <code>$1</code> <code>$2</code> … <code>$n</code> 的形式输出所有参数。</p></li><li><p><code>$$</code>:   脚本运行的当前进程 ID 号</p></li><li><p><code>$!</code>:  后台运行的最后一个进程的 ID 号</p></li><li><p><code>$@</code>:   与 <code>$*</code> 相同，但是使用时加引号，并在引号中返回每个参数。 如 <code>&quot;$@&quot;</code> 用 <code>「&quot;」</code> 括起来的情况、以 <code>&quot;$1&quot;&quot;$2&quot; … &quot;$n&quot;</code> 的形式输出所有参数。</p></li><li><p><code>$-</code>:   显示 Shell 使用的当前选项，与 <span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9saW51eC9saW51eC1jb21tLXNldC5odG1s">set 命令<i class="fa fa-external-link-alt"></i></span> 功能相同。</p></li><li><p><code>$?</code>:  显示最后命令的退出状态。0 表示没有错误，其他任何值表明有错误。</p></li></ul><h4 id="Read-命令"><a href="#Read-命令" class="headerlink" title="Read 命令"></a><code>Read</code> 命令</h4><p>默认接受键盘的输入，回车符代表输入结束</p><ul><li><p><code>-p</code>: 打印信息</p></li><li><p><code>-t</code>: 限定时间</p></li><li><p><code>-s</code>: 不回显</p></li><li><p><code>-n</code>: 输入字符个数</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">clear</span><br><span class="line"><span class="built_in">echo</span> -n -e <span class="string">&quot;type something&quot;</span></span><br><span class="line"><span class="built_in">read</span> var</span><br><span class="line"><span class="built_in">echo</span>  <span class="string">&quot;you typed:&quot;</span> <span class="variable">$var</span></span><br></pre></td></tr></table></figure><h2 id="shell-变量"><a href="#shell-变量" class="headerlink" title="shell 变量"></a>shell 变量</h2><h3 id="变量的操作"><a href="#变量的操作" class="headerlink" title="变量的操作"></a>变量的操作</h3><ul><li><p>定义变量格式: <code>变量名 = 值</code>(不能有空号)</p></li><li><p>使用 <code>$</code> 进行变量的读取</p></li><li><p>使用 <code>unset 变量名 </code> 取消变量</p></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li><p>本地变量：用户私有变量，只有 <strong>本用户可以使用</strong>，保存在家目录下的 <code>.bash_profile</code>、<code>.bashrc</code> 文件中</p></li><li><p>全局变量：<strong>所有用户都可以使用</strong>，保存在 <code>/etc/profile</code>、<code>/etc/bashrc</code> 文件中。使用 <code>export 变量名 = 变量值 </code> 进行全局变量的定义</p></li><li><p>用户自定义变量：用户自定义，比如脚本中的变量，终端关闭或者关机，都会丢失，</p></li></ol><h2 id="shell-数组"><a href="#shell-数组" class="headerlink" title="shell 数组"></a>shell 数组</h2><h3 id="基本数组"><a href="#基本数组" class="headerlink" title="基本数组"></a>基本数组</h3><h4 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h4><ul><li>定义: <code> 数组名称 =(元素 1 元素 2 元素 3 ...)</code></li><li>数组的读出 <code>$&#123;数组名称&#125;[index]</code></li></ul><h4 id="数组的赋值"><a href="#数组的赋值" class="headerlink" title="数组的赋值"></a>数组的赋值</h4><p>方法一: 一次赋一个值</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array0[0]=<span class="string">&#x27;tom&#x27;</span></span><br></pre></td></tr></table></figure><p>方法二: 一次赋予多个值</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array2=(tom jack alice)</span><br><span class="line"></span><br><span class="line">array3=(<span class="built_in">cat</span> /etc/passwd) <span class="comment">#希望是将该文件中的每一个行作为一个元素赋值给数组 array3</span></span><br><span class="line"></span><br><span class="line">array4=(<span class="built_in">ls</span> /var/ftp/Shell/for*)</span><br><span class="line"></span><br><span class="line">array5=(tom jack alice “bash shell”)</span><br></pre></td></tr></table></figure><h4 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array1[0]&#125;</span> 访问数组中的第一个元素</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array1[@]&#125;</span> 访问数组中所有元素 等同于 <span class="built_in">echo</span> <span class="variable">$&#123;array1[*]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#array1[@]&#125;</span> 统计数组元素的个数</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!array2[@]&#125;</span> 获取数组元素的索引</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array1[@]:1&#125;</span> 从数组下标 1 开始</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array1[@]:1:2&#125;</span> 从数组下标 1 开始，访问两个元素</span><br></pre></td></tr></table></figure><h3 id="联合数组"><a href="#联合数组" class="headerlink" title="联合数组"></a>联合数组</h3><p>关联数组可以允许用户自定义数组的索引，这样使用起来更加方便、高效。</p><p><strong>需要先申明该数组为关联数组</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">declare</span> -A a_array</span><br><span class="line">a_array=([name]=<span class="string">&#x27;joey&#x27;</span> [age]=<span class="string">&#x27;25&#x27;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;a_array[name]&#125;</span></span><br></pre></td></tr></table></figure><p><strong>访问数组元素：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;ass_array2[index2]&#125;</span> 访问数组中的第二个元数</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;ass_array2[@]&#125;</span> 访问数组中所有元数 等同于 <span class="built_in">echo</span> <span class="variable">$&#123;array1[*]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#ass_array2[@]&#125;</span> 获得数组元数的个数</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!ass_array2[@]&#125;</span> 获得数组元数的索引</span><br></pre></td></tr></table></figure><hr><p>相关教程和书籍:</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zMDM1OTk1NC8=">鸟哥的Linux私房菜 基础学习篇 第四版 (豆瓣)<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmFwZWxhbmQuY24vZGV0YWlscy8xMi8=">路飞学城 shell 教程<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC82ODA2ODYyLw==">The Linux Command Line <i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9iYXNoLw==">Bash 脚本教程 - 网道<i class="fa fa-external-link-alt"></i></span></li></ol><p>接着入门: <a href="https://tech-garden.top/articles/98e16645.html">https://tech-garden.top/articles/98e16645.html</a></p><center>--- 全文完 ---</center>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell 脚本编程-2</title>
      <link href="/articles/98e16645.html"/>
      <url>/articles/98e16645.html</url>
      
        <content type="html"><![CDATA[<p>前置文章：<a href="https://tech-garden.top/articles/98e16645.html">https://tech-garden.top/articles/98e16645.html</a></p><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="shell-中的比较运算"><a href="#shell-中的比较运算" class="headerlink" title="shell 中的比较运算"></a>shell 中的比较运算</h3><h4 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h4><p>  运算符解释</p><ul><li><code>-eq</code>       等于</li><li><code>-gt</code>       大于</li><li><code>-lt</code>       小于</li><li><code>-ge</code>       大于或等于</li><li><code>-le</code>       小于或等于</li><li><code>-ne</code>       不等于</li></ul><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p>运算符解释，注意字符串一定别忘了使用引号引起来</p><ul><li><code>==</code> 等于</li><li><code>!=</code> 不等于</li><li><code>-n</code> 检查字符串长度是否大于 0</li><li><code>-z</code> 检查字符串长度是否为 0</li></ul><h4 id="文件的检查和比较"><a href="#文件的检查和比较" class="headerlink" title="文件的检查和比较"></a>文件的检查和比较</h4><ul><li><code>-d</code> 是否存在且为目录</li><li><code>-e</code> 检查文件是否存在</li><li><code>-f</code> 检查文件是否存在且为文件</li><li><code>-s</code> 检查文件是否存在且可读</li><li><code>-w</code> 检查文件是否存在且不为空</li><li><code>-x </code> 检查文件是否存在且可写</li><li><code>-O</code> 检查文件是否存在且可执行</li><li><code>-G</code> 检查文件是否存在并且被当前用户拥有</li><li><code> file1 -nt file2</code>  检查 file1 是否比 file2 新</li><li><code>file1 -ot file2</code> 检查 file1 是否比 file2 旧</li></ul><h3 id="if-语法"><a href="#if-语法" class="headerlink" title="if 语法"></a><code>if</code> 语法</h3><p>if 条件要加 <code>[]</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [condition]</span><br><span class="line">   <span class="keyword">then</span></span><br><span class="line">      commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h4 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a><code>if-else</code></h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [condition]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        commands2</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h4 id="if-else-elseif"><a href="#if-else-elseif" class="headerlink" title="if-else-elseif"></a><code>if-else-elseif</code></h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [condition 1]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands1</span><br><span class="line"><span class="keyword">elif</span> [condition 2]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        commands2</span><br><span class="line">  .......</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commandsX</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h4 id="if-的高级用法"><a href="#if-的高级用法" class="headerlink" title="if 的高级用法"></a><code>if</code> 的高级用法</h4><ul><li><p>🍋条件符号使用双圆括号 <code>(())</code>，<strong>可以在条件中植入数学表达式</strong></p></li><li><p>🍋使用双方括号 <code>[[]]</code>, 可以在条件中 <strong>使用通配符</strong></p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> ((100*3+10&gt;500 ));<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&gt;&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;&lt;&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> str <span class="keyword">in</span> java javascript js</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [[<span class="string">&quot;<span class="variable">$str</span>&quot;</span> == j*]];<span class="keyword">then</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str</span>&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><h4 id="for-语法"><a href="#for-语法" class="headerlink" title="for 语法"></a>for 语法</h4><ul><li><p>语法 1: 有限变量</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> v1 v2 v3..</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>语法 2: C 语言写法</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((变量; 条件; 变化))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>语法 3: 无限循环</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((;;))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><ul><li><code>continue</code> 跳过循环中的某次循环</li><li><code>break</code> 跳出循环继续执行后续代码, 可以使用 <code>break N</code> 循环退出, 循环从里往外排序为 <code>1 - N</code></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> ((i=9;i&gt;0;i--))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [<span class="variable">$i</span> -eq 5]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> -n -e <span class="string">&quot;\b<span class="variable">$i</span>===&quot;</span></span><br><span class="line">        <span class="built_in">sleep</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> -e</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;100;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ha&quot;</span></span><br><span class="line"><span class="keyword">for</span>((;;))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;the inner loop&quot;</span></span><br><span class="line">        <span class="built_in">break</span> 2</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">打印:</span><br><span class="line">ha</span><br><span class="line">the inner loop</span><br></pre></td></tr></table></figure><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><h4 id="语法格式-条件可以是-5-种运算中的任意一种"><a href="#语法格式-条件可以是-5-种运算中的任意一种" class="headerlink" title="语法格式: 条件可以是 5 种运算中的任意一种"></a>语法格式: 条件可以是 5 种运算中的任意一种</h4><p><strong>数学, 字符串比较, 文件类型, 逻辑运算, 赋值运算</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [condition]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="until"><a href="#until" class="headerlink" title="until"></a>until</h4><p><code>while</code> 是条件为真开始时循环, <code>until</code> 是条件为假开始循环.</p><h4 id="case-多条件执行语句"><a href="#case-多条件执行语句" class="headerlink" title="case (多条件执行语句)"></a>case (多条件执行语句)</h4><p><strong>语法 (比较奇怪):</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> var <span class="keyword">in</span></span><br><span class="line">condition1)</span><br><span class="line">command1</span><br><span class="line">;;</span><br><span class="line">condition1)</span><br><span class="line">command2</span><br><span class="line">;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p><strong>注意特殊的变量</strong></p><h2 id="shell-函数"><a href="#shell-函数" class="headerlink" title="shell 函数"></a>shell 函数</h2><h3 id="函数语法"><a href="#函数语法" class="headerlink" title="函数语法"></a>函数语法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式 1</span></span><br><span class="line"><span class="function"><span class="title">func_name</span></span> ()&#123;</span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="built_in">return</span> N</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 方式 2</span></span><br><span class="line"><span class="keyword">function</span> func_name&#123;</span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="built_in">return</span> N</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>直接使用函数名字, 不加括号: <code>func_name</code></p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><h3 id="定位字符-锚定字符"><a href="#定位字符-锚定字符" class="headerlink" title="定位字符: 锚定字符"></a>定位字符: 锚定字符</h3><ul><li><code>^</code> 锚定开头 <code>^a</code> 以 a 开头, 默认锚定一个字符</li><li><code>$</code> 锚定结尾 <code>a$</code> 以 a 结尾, 默认锚定一个字符</li><li><code>^$</code> 两个字符在一起表示精准匹配</li><li><code>grep</code> 默认不支持正则表达式, 需要加上 <code>-e</code> 参数, 或者使用 <code>egrep</code></li></ul><p>其他特定符号的意思</p><h3 id="匹配符-匹配字符串"><a href="#匹配符-匹配字符串" class="headerlink" title="匹配符: 匹配字符串"></a>匹配符: 匹配字符串</h3><ul><li><code>.</code> 除了回车符号任意的字符</li><li><code>(|)</code> 字符串分组 <code>^(a|b)c$</code> a 或者 b 开头以 c 结尾的串</li><li><code>[]</code> 定义字符类, 匹配括号中的一个字符</li><li><code>[^]</code> 表示否定括号中出现字符类中的字符, 取反</li><li><code>\</code> 转义字符</li><li><code>|</code> 或符号</li></ul><h3 id="限定符号-对前面的字符或者字符串做限定说明"><a href="#限定符号-对前面的字符或者字符串做限定说明" class="headerlink" title="限定符号 : 对前面的字符或者字符串做限定说明"></a>限定符号 : 对前面的字符或者字符串做限定说明</h3><ul><li><code>*</code> 某个字符之后加星号表示该字符不出现或出现多次 (**0 次或者多次 **)</li><li><code>?</code> 与星号相似，但略有变化，表示该字符出现一次或不出现 <strong>(0 次或者 1 次)</strong></li></ul><ul><li><code>+</code> 与星号相似，表示其前面字符出现 ** 一次或多次 <strong>，</strong> 但必须出现一次 **</li><li><code>&#123;n,m&#125;</code>某个字符之后出现，表示该字符 ** 最少 <strong><code>n</code> 次，</strong> 最多 **<code>m</code> 次</li><li><code>&#123;m&#125;</code>正好出现了 <code>m</code> 次</li></ul><h3 id="POSIX-特殊字符"><a href="#POSIX-特殊字符" class="headerlink" title="POSIX 特殊字符"></a>POSIX 特殊字符</h3><ul><li><code>[:alnum:]</code>匹配任意字母字符 0-9 a-z A-Z</li><li><code>[:alpha:]</code>匹配任意字母，大写或小写</li><li><code>[:digit:]</code>数字 0-9</li><li><code>[:graph:]</code>非空字符 ( 非空格控制字符)</li><li><code>[:lower:]</code>小写字符 a-z</li><li><code>[:upper:]</code>大写字符 A-Z</li><li><code>[:cntrl:]</code>控制字符</li><li><code>[:print:]</code>非空字符 ( 包括空格)</li><li><code>[:punct:]</code>标点符号</li><li><code>[:blank:]</code>空格和 TAB 字符</li><li><code>[:xdigit:]</code>16 进制数字</li><li><code>[:space:]</code>所有空白字符 ( 新行、空格、制表符)</li></ul><h2 id="shell-文件操作"><a href="#shell-文件操作" class="headerlink" title="shell 文件操作"></a>shell 文件操作</h2><p>非交互式文件操作, vim 和 nano 是交互式文件操作.</p><h3 id="sed-stream-editor"><a href="#sed-stream-editor" class="headerlink" title="sed (stream editor)"></a>sed (stream editor)</h3><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvOTEwNC5odG1s">CoolShell 的 sed 简明教程<i class="fa fa-external-link-alt"></i></span></p><h3 id="awk-pattern-directed-scanning-and-processing-language"><a href="#awk-pattern-directed-scanning-and-processing-language" class="headerlink" title="awk(pattern-directed scanning and processing language)"></a>awk(pattern-directed scanning and processing language)</h3></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvOTA3MC5odG1s">CoolShell 的 AWK 简明教程<i class="fa fa-external-link-alt"></i></span></p></li></ul><h2 id="常见的-shell-案例"><a href="#常见的-shell-案例" class="headerlink" title="常见的 shell 案例"></a>常见的 shell 案例</h2><h3 id="监控主机是否存活的脚本"><a href="#监控主机是否存活的脚本" class="headerlink" title="监控主机是否存活的脚本"></a>监控主机是否存活的脚本</h3><details><summary> 监控主机是否存活的脚本 </summary><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((;;))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ping -c1 <span class="variable">$1</span> &amp;&gt;/dev/null</span><br><span class="line">    <span class="keyword">if</span> [$? -eq 0]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">&quot;`date +&quot;</span>%F %H:%M;%S<span class="string">&quot;`:<span class="variable">$1</span> is \033[32m UP\033[0m&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">&quot;`date +&quot;</span>%F %H:%M;%S<span class="string">&quot;`:<span class="variable">$1</span> is \033[31m DOWN \033[0m&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># controll the frequency</span></span><br><span class="line">    <span class="built_in">sleep</span> 5</span><br><span class="line">    <span class="comment">#in production usually use at least 60</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></details><h3 id="nginx-启动脚本"><a href="#nginx-启动脚本" class="headerlink" title="nginx 启动脚本"></a>nginx 启动脚本</h3><details><summary>nginx 启动脚本</summary><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># variables definition</span></span><br><span class="line">nginx_dir=/usr/local/nginx</span><br><span class="line">nginxd=<span class="variable">$nginx_dir</span>/sbin/nginx</span><br><span class="line">pid=<span class="variable">$nginx_dir</span>/logs/nginx.pid</span><br><span class="line">conf=<span class="variable">$nginx_dir</span>/conf/nginx.conf</span><br><span class="line">proc=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># Source the function library</span></span><br><span class="line"><span class="keyword">if</span> [-f /etc/init.d/functions]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># . means source the function</span></span><br><span class="line">    .  /etc/init.d/functions</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;file not found  /etc/init.d/functions&quot;</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [-f <span class="variable">$pid_file</span>];<span class="keyword">then</span></span><br><span class="line">    nginx_process_name=`<span class="built_in">cat</span> <span class="variable">$pid</span> `</span><br><span class="line">    nginx_process_num=`ps aux | grep <span class="variable">$nginx_process_name</span>| grep -v <span class="string">&quot;grep&quot;</span>| <span class="built_in">wc</span> -l `</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># start func</span></span><br><span class="line"><span class="function"><span class="title">start</span></span>()&#123;</span><br><span class="line"><span class="comment"># judge the file by the pid file if the nginx is running then alert something</span></span><br><span class="line"><span class="keyword">if</span> [-f <span class="variable">$pid</span>] &amp;&amp; [ <span class="variable">$nginx_process_num</span> -ge 1 ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;nginx is already runnig&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> [-f <span class="variable">$pid</span>] &amp;&amp; [ <span class="variable">$nginx_process_num</span> -le 1 ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">rm</span> -f <span class="variable">$pid_file</span></span><br><span class="line">       <span class="comment"># echo &quot;nginx start `daemon $nginxd`&quot;</span></span><br><span class="line">        action <span class="string">&quot;nginx start&quot;</span> <span class="variable">$nginxd</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># echo &quot;nginx start `daemon $nginxd`&quot;</span></span><br><span class="line">    action <span class="string">&quot;nginx start&quot;</span> <span class="variable">$nginxd</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">stop</span></span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> [-f <span class="variable">$pid</span>] &amp;&amp; [ <span class="variable">$nginx_process_num</span> -ge 1 ];<span class="keyword">then</span></span><br><span class="line">            action <span class="string">&quot;nginx stop&quot;</span>  killall -s QUIT <span class="variable">$proc</span></span><br><span class="line">            <span class="built_in">rm</span> -f <span class="variable">$pid</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            action <span class="string">&quot;nginx stop&quot;</span> killall -s QUIT <span class="variable">$proc</span> 2&gt;/dev/null</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">restart</span></span>()&#123;</span><br><span class="line">    stop</span><br><span class="line">    <span class="built_in">sleep</span> 1</span><br><span class="line">    start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">reload</span></span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> [-f <span class="variable">$pid</span>] &amp;&amp; [ <span class="variable">$nginx_process_num</span> -ge 1 ];<span class="keyword">then</span></span><br><span class="line">        action <span class="string">&quot;nginx reload&quot;</span> killall -s HUP <span class="variable">$proc</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        action <span class="string">&quot;nginx reload&quot;</span> killall -s HUP <span class="variable">$proc</span> 2&gt;/dev/null</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">status</span></span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> [-f <span class="variable">$pid</span>] &amp;&amp; [ <span class="variable">$nginx_process_num</span> -ge 1 ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;nginx runnig&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;nginx not running&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># call the funcs</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">    start)start;;</span><br><span class="line">    stop)stop;;</span><br><span class="line">    restart)restart;;</span><br><span class="line">    reload)reload;;</span><br><span class="line">    status)status;;</span><br><span class="line">    *) <span class="built_in">echo</span> <span class="string">&quot;USAGE: <span class="variable">$0</span> start|stop|restart|reload|status&quot;</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></details><hr><p>相关教程和书籍:</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC8zMDM1OTk1NC8=">鸟哥的Linux私房菜 基础学习篇 第四版 (豆瓣)<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmFwZWxhbmQuY24vZGV0YWlscy8xMi8=">路飞学城 shell 教程<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ib29rLmRvdWJhbi5jb20vc3ViamVjdC82ODA2ODYyLw==">The Linux Command Line <i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93YW5nZG9jLmNvbS9iYXNoLw==">Bash 脚本教程 - 网道<i class="fa fa-external-link-alt"></i></span></li></ol><center>--- 全文完 ---</center>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList 源码分析</title>
      <link href="/articles/392f85e6.html"/>
      <url>/articles/392f85e6.html</url>
      
        <content type="html"><![CDATA[<h2 id="ArrayList-的结构"><a href="#ArrayList-的结构" class="headerlink" title="ArrayList 的结构"></a>ArrayList 的结构</h2><ul><li>在逻辑结构上是：线性结构、线性表</li><li>在物理结构是：连续储存结构</li></ul><h2 id="ArrayList-实现的接口"><a href="#ArrayList-实现的接口" class="headerlink" title="ArrayList 实现的接口"></a>ArrayList 实现的接口</h2><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;<span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;,</span><br><span class="line">RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf3hoj29ydj30yu0jijs1.jpg"></p><h3 id="RandomAccess"><a href="#RandomAccess" class="headerlink" title="RandomAccess"></a><code>RandomAccess</code></h3><p><code>RandomAccess</code>，没有方法，是一个标记的接口。List 实现这个接口用来表示其支持随机访问：即下标访问，（<strong>通常是固定时间</strong>）<code>RandomAccess</code> 这个标记接口就是标记能够随机访问元素的集合， 简单来说就 <strong>是底层是数组实现</strong> 的集合。 <code>for (int i=0, n=list.size(); i &lt; n; i++)</code> 循环，比 <code>for (Iterator i=list.iterator(); i.hasNext(); )i.next();</code> 要快。（快速随机访问速度 &gt; 迭代器遍历速度。）</p><h3 id="Cloneable"><a href="#Cloneable" class="headerlink" title="Cloneable"></a><code>Cloneable</code></h3><p>空接口，实现了这个接口，在使用 <code>Object.clone()</code> 方法进行每个字段的拷贝是合法的，没有实现这个方法会抛出 <code>CloneNotSupportedException</code>。接口不包含 <code>clone</code> 方法，及时这个实现了这个接口，也不能进行 clone，即使是使用反射。实现此接口的类应该使用公共方法覆盖 clone 方法.</p><h2 id="ArrayList-属性"><a href="#ArrayList-属性" class="headerlink" title="ArrayList 属性"></a>ArrayList 属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">// 用于默认大小空实例的共享空数组实例，与 EMPTY_ELEMENTDATA 的区别在于知道当第一个元素插入时该如何扩充数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="comment">// 保存了多少个数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"><span class="comment">// 最大的长度，2^31 - 8 减去头关键字</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h2 id="ArrayList-构造方法-3-个"><a href="#ArrayList-构造方法-3-个" class="headerlink" title="ArrayList 构造方法(3 个)"></a>ArrayList 构造方法(3 个)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有初始容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity:&quot;</span> + initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无初始容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用其他集合来初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            <span class="comment">// 调用 Array.copyOf</span></span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="ArrayList 扩容机制"></a>ArrayList 扩容机制</h2><p>在初始化 <code>ArrayList</code> 的时候，JVM 并不知道要存多少个数据，但是数组必须要声明其大小。这样的话，<strong>最迟</strong> 在第一个元素插入时，必须指定数组容量大小、初始化数组以容纳元素。</p><h2 id="ArrayList-添加方法"><a href="#ArrayList-添加方法" class="headerlink" title="ArrayList 添加方法"></a>ArrayList 添加方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接添加元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在指定的位置加上元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                    size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看到的是带三个感叹号的注释 <code>// Increments modCount!!</code>，这个 <code>modCount</code> 是干什么呢的?</p><ul><li><p>点进去发现是继承自 <code>AbstractList</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>  这个属性就是：<strong>已对该列表进行结构化的修改次数</strong>，否则的话会干扰正在迭代的，产生错误的结果。如果这个 field 变换不正常的话，就会在听下一个迭代（next，remove，previous，set，add 操作的时候）产生在并发里面很常见的并发修改异常（这就是根源。Man, I Learned so much.）<code>ConcurrentModificationException</code>。</p><p>  面对迭代过程中的并发修改，这提供了 <strong>快速故障 fast-fail</strong> 行为，而不是不确定的行为。</p><p>  如果子类希望提供快速失败的迭代器（和列表迭代器），则只需在其 <code>add（int E）</code>和 <code>remove（int E）</code>方法（以及任何其他覆盖该方法导致结构化的方法）中递增此字段即可。 在添加或者移出的时候，这个加不能超过一个。否则会抛出虚假的 <code>ConcurrentModificationException</code>。</p></li></ul><p>接着看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是第一次添加数据，是无参构造第一次添加数据</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// 获取到 10 和 size+1</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 避免并发修改异常</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length&gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 进行扩容</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 原来 * 1.5 使用位运算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity&gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE&gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以扩容的最大容量，当想要扩容的容量大于 MAX_ARRAY_SIZE 时调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 是否扩容的时候变成了负数</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow 内存不足</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity&gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>有 <code>index</code> 添加会进行 index range check, 没有 <code>index</code> 就进行保证容量的的方法</li><li>先计算容量判断是否是默认容量 <code>10</code>，就返回 <code>Math.max(DEFAULT_CAPACITY, index);</code> 或者 <code>index</code></li><li>拿到上面的值 <code>a</code>, 先加 <code>modCount++</code>，如果 <code>a</code> 大于存储元素的长度的话就进行 <code>grow</code> 操作</li><li>加入需要 <code>grow</code>，传入最大值<ol><li>拿到原来数组的长度 <code>*1.5</code>，用位运算</li><li>如过 <code>*1.5</code> 后，还小于 <code>a</code>，就返回 <code>a</code></li><li>如果大于 <code>2^31-8</code>, 就进行 <code>hugeCapacity</code> 操作（判断是否溢出，就抛出来内存不足异常, 否则就返回，<code>MAX_ARRAY_SIZE</code>），否则就调用 <code>Arrays.copyOf</code> 方法进行拷贝。</li></ol></li></ol><h2 id="什么时候扩容？"><a href="#什么时候扩容？" class="headerlink" title="什么时候扩容？"></a>什么时候扩容？</h2><ol><li>主动扩容: 从 <code>public void ensureCapacity(int minCapacity)</code> 可以看出，我们可以主动调用该方法进行扩容。</li><li>添加时候扩容: 在调用 <code>add/addAll</code> 等添加元素的方法时，<code>ArrayList</code> 也会调用内部扩容方法（ensureCapacityInternal）来主动扩容</li></ol><p>见代码如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minExpand</span> <span class="operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity&gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length&gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组底层的方法"><a href="#数组底层的方法" class="headerlink" title="数组底层的方法"></a>数组底层的方法</h3><p>扩容的时候其实调用了 <code>Arrays.copyOf </code> 方法，最后也是调用了 <code>System.arraycopy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Arrays.copyOf</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="type">int</span> newLength, Class&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>[]&gt; newType) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                        Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; getComponentType();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  System 中的 copy ：native 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,  <span class="type">int</span>  srcPos,</span></span><br><span class="line"><span class="params">                                        Object dest, <span class="type">int</span> destPos,</span></span><br><span class="line"><span class="params">                                        <span class="type">int</span> length)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="其他几个-public-方法"><a href="#其他几个-public-方法" class="headerlink" title="其他几个 public 方法"></a>其他几个 public 方法</h2><ul><li><code>clear()</code> <code>fori</code> 将每个元素设置为 <code>null</code>，让 gc 做工作。</li><li><code>clone()</code> 调用父类的 <code>clone</code> 方法，生成新 <code>ArrayList</code>，然后把数据 copy 过去（<code>Arrays.copy</code>）,<code>modCount=0</code>。</li><li><code>toArray()</code> <code>Arrays.copy</code> 返回新拷贝的数据。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>基于数组实现, 默认长度 10</p></li><li><p>可以动态扩容，每次 <code>*1.5</code> 倍的长度增加</p></li><li><p>元素可以为 <code>null</code></p></li><li><p>不是并发安全的，是通过 <code>modCount</code> 来进行判断的</p></li><li><p>如果想并发安全：</p><ol><li><code>Vector</code> 不行, 效率低</li><li>使用 <code>Collections.synchronizedList</code>()</li><li>JUC 中的并发容器 <code>new CopyOnWriteArrayList&lt;&gt;()</code>;</li></ol></li><li><p>为什么数组中的最大元素是 <code>Integer.MAX_VALUE - 8</code></p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU3NTYyNzcvd2h5LXRoZS1tYXhpbXVtLWFycmF5LXNpemUtb2YtYXJyYXlsaXN0LWlzLWludGVnZXItbWF4LXZhbHVlLTg=">stackoverflow<i class="fa fa-external-link-alt"></i></span><blockquote><p>数组对象（例如 int 值的数组）的形状和结构类似于标准 Java 对象的形状和结构。主要区别在于，数组对象还有一条额外的元数据，它表示数组的大小。然后，数组对象的元数据包括：Class：指向类信息的指针，该信息描述对象的类型。对于 int 字段数组，这是指向 int [] 类的指针。<br>标志：描述对象状态的标志的集合，包括对象的哈希码（如果有的话）以及对象的形状（即，对象是否为数组）。<br>Lock：对象的同步信息，即对象当前是否同步。<br>Size：数组的大小。</p></blockquote></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9qYXZhL2xpYnJhcnkvai1jb2RldG9oZWFwL2k=">From Java code to Java heap<i class="fa fa-external-link-alt"></i></span></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> Java容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 好用的插件备忘</title>
      <link href="/articles/7992296d.html"/>
      <url>/articles/7992296d.html</url>
      
        <content type="html"><![CDATA[<h2 id="👨‍💻-开发类"><a href="#👨‍💻-开发类" class="headerlink" title="👨‍💻 开发类"></a>👨‍💻 开发类</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzExNTEyLWphdmEtdmlzdWFsaXplcg==">Java Visualizer - debug 时用图展示堆栈信息，很神奇<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzcxMTUtdmlzdWFsdm0tbGF1bmNoZXI=">VisualVM Launcher - Java 故障排除工具，JVM 可视化<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzc0OTUtLWlnbm9yZQ==">.ignore - 识别 ignore files<i class="fa fa-external-link-alt"></i></span><span id="more"></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzEwNTUwLWFkZC10by1naXRpZ25vcmU=">Add to gitignore - 通过右键添加文件到 .gitignore 文件<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzE3ODA5LWFsaWJhYmEtY2xvdWQtYWktY29kaW5nLWFzc2lzdGFudA==">Alibaba Cloud AI Coding Assistant - 代码提示<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzEwMDQ2LWFsaWJhYmEtamF2YS1jb2RpbmctZ3VpZGVsaW5lcw==">Alibaba Java Coding Guidelines - 阿里的 Java 代码检测<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzE0NTU3LXZpc3VhbGdj">VisualGC - 实时可视化 Hotspot JVM 垃圾回收监控工具<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzE3NzE4LWdpdGh1Yi1jb3BpbG90">GitHub Copilot - github 代码智能补全<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzc0OTktZ2l0dG9vbGJveA==">GitToolBox - 增加了 git 的集成<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzcxMjUtZ3JlcC1jb25zb2xl">Grep Console - 通过正则配置的颜色高亮 log<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzQ0NDEtanJlYmVsLWFuZC14cmViZWw=">JRebel and XRebel - 热部署插件<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzEyMDY2LXBvam8tdG8tanNvbg==">POJO to JSON - 拷贝 Java 类成 JSON 格式<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzgyODYtc2VxdWVuY2VkaWFncmFt">SequenceDiagram - 生成方法的时序图<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzIxNjItc3RyaW5nLW1hbmlwdWxhdGlvbg==">String Manipulation - 转换string: 大小写切换、排序、过滤、递增、与列对齐、grepping、转义、编码<i class="fa fa-external-link-alt"></i></span></li></ul><h2 id="🪷-美化类"><a href="#🪷-美化类" class="headerlink" title="🪷 美化类"></a>🪷 美化类</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzEzMjI0LWJyZWV6ZS1kYXJr">Breeze Dark - 比自带黑色主体更舒服的主题<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzE2NjA0LWV4dHJhLXRvb2x3aW5kb3ctY29sb3JmdWwtaWNvbnM=">Extra ToolWindow Colorful Icons - 给 IDE 图标加上颜色<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzEyOTk1LXRyYXNoLXBhbmRhLXRoZW1l">Trash Panda Theme - 一款很好看的主题<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzE1MDkwLXBva2Vtb24tcHJvZ3Jlc3M=">Pokemon Progress - 美化进度条<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wbHVnaW5zLmpldGJyYWlucy5jb20vcGx1Z2luLzEzMzA5LWNvbG9yLWhpZ2hsaWdodGVy">Color Highlighter - 高亮代码中的颜色<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA - 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文本换行符号(^M)导致的 git diff 问题</title>
      <link href="/articles/8e8cc4d1.html"/>
      <url>/articles/8e8cc4d1.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>文件改动了一点，但是在 gitlab&#x2F;github 看 diff 却发现整个文件全部都进行了改动，且文件变的乱序或者变成了一行。</p><h2 id="原因-文件换行符导致"><a href="#原因-文件换行符导致" class="headerlink" title="原因: 文件换行符导致"></a>原因: 文件换行符导致</h2><p>文本换行符号通常有: LF 和 CRLF。</p><span id="more"></span><p>首先介绍 LF 和 CRLF 下是什么：</p><ul><li><strong>CRLF</strong>: 是 carriagereturnlinefeed 的缩写。中文意思是回车换行；</li><li><strong>LF</strong>: 是 line feed 的缩写，中文意思是换行；</li><li><strong>CR</strong>: 是 carriagereturn 的缩写。中文意思是回车；</li></ul><p>为什么换行回车会不同呢? 主要的原因在于操作系统之间的分歧：</p><ul><li>早期的 macOS 系统使用 CR 当做换行，现在也已经统一成了 LF。</li><li>Unix(包含现在大量使用的 linux) 系统使用 LF</li><li>Windows 系统使用 LFCR 当做换行</li></ul><p>也正是因为不同系统的分歧，在多人协作共同开发的时候，可能导致提交代码时候产生问题。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="1-IDE-或者代码编辑器中统一将换行符修改为-LF"><a href="#1-IDE-或者代码编辑器中统一将换行符修改为-LF" class="headerlink" title="1. IDE 或者代码编辑器中统一将换行符修改为: LF"></a>1. IDE 或者代码编辑器中统一将换行符修改为: LF</h3><h3 id="2-在-git-中进行配置"><a href="#2-在-git-中进行配置" class="headerlink" title="2. 在 git 中进行配置"></a>2. 在 git 中进行配置</h3><p>git 为了防止以上问题扰乱跨平台合作开发，使用命令可以转化 LF 和 CRLF<br>具体命令为：</p><ol><li><p><code>git config --global core.autocrlf true</code>: Git 可以在你 push 时自动地把行结束符 CRLF 转换成 LF，而在 pull 代码时把 LF 转换成 CRLF。用 core.autocrlf 来打开此项功能，如果是在 Windows 系统上，把它设置成 true，这样当签出代码时，LF 会被转换成 CRLF</p></li><li><p><code>git config --global core.autocrlf input</code>: Linux 或 Mac 系统使用 LF 作为行结束符；当一个以 CRLF 为行结束符的文件不小心被引入时你肯定想进行修正，把 core.autocrlf 设置成 input 来告诉 Git 在 push 时把 CRLF 转换成 LF，pull 时不转换</p></li><li><p><code>git config --global core.autocrlf false</code>: 在本地和代码库中都保留 CRLF，无论 pull 还是 push 都不变，代码库什么样，本地还是什么样子</p></li></ol><p>参考链接:</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoZW56aG91X3loL2FydGljbGUvZGV0YWlscy8xMDU1MDc1NDk=">IDEA 批量替换文件换行符、分隔符 CRLF、LF、CR_shenzhou_yh 的博客<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3Nkbi5uZXQvdGFncy9NdFRhQWcyc05EWTJNRGt6TFdKc2IyY08wTzBPLmh0bWw=">idea 换行格式指定为 LF<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGV0aWFuYmlqaS5jb20vZ2l0L2dpdC1jcmxmLmh0bWw=">git 解决换行符 ^M 导致整个文件被改 - 乐天笔记<i class="fa fa-external-link-alt"></i></span></li></ul><!-- - www.baidu.com -->]]></content>
      
      
      <categories>
          
          <category> BugMemo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文本换行符号 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话数据结构》读书笔记</title>
      <link href="/articles/7ef02f1c.html"/>
      <url>/articles/7ef02f1c.html</url>
      
        <content type="html"><![CDATA[<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h3><p>逻辑结构: 数据对象和数据元素中的关系:</p><ol><li>集合结构: 集合中的元素除了处于同一集合外, 之间没有其他关系.</li><li>线性结构: 线性结构中的数据元素之间的关系是一对一的关系</li><li>树形结构: 数据元素之间存在一对多的关系</li><li>图形结构: 多对多</li></ol><span id="more"></span><p>物理结构: 在计算机中的储存形式</p><ol><li>顺序储存结构: 连续的储存单元中</li><li>链式储存结构: 可以连续也可以不连续</li></ol><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法定义: 算法是解决特定问题的求解步骤的描述, 在计算机中表现为指令的有限序列, 每一条指令表示一个或者多个操作.</p><h3 id="2-1-算法的特性"><a href="#2-1-算法的特性" class="headerlink" title="2.1 算法的特性"></a>2.1 算法的特性</h3><p>5 个: 输入, 输出, 又穷性, 确定性和可行性.</p><ul><li>输入输出: 0 个或者多个输入, 至少一个输出.</li><li>有穷性: 算法在执行有限的步骤后, 自动结束并且不会无限循环, 每一个步骤在可接受的时间内完成.</li><li>确定性: 算法的每一个步骤都有确定的含义, 不会出现二义性.</li><li>可行性: 算法的每一步必须是可行的, 也就是说, 每一步都能够通过执行有限次数完成.</li></ul><p>好的算法的特点: 可读性, 健壮性, 时间效率高和储存量低.</p><h3 id="2-2-算法时间复杂度"><a href="#2-2-算法时间复杂度" class="headerlink" title="2.2 算法时间复杂度"></a>2.2 算法时间复杂度</h3><h3 id="2-3-大-O-阶方法"><a href="#2-3-大-O-阶方法" class="headerlink" title="2.3 大 O 阶方法"></a>2.3 大 O 阶方法</h3><h3 id="2-4-常见的阶"><a href="#2-4-常见的阶" class="headerlink" title="2.4 常见的阶"></a>2.4 常见的阶</h3><ul><li>常数阶 <code>O(1)</code></li><li>线性阶 <code>O(n)</code></li><li>对数阶 <code>O(logN)</code></li><li>平方阶 <code>O(n^2)</code></li><li>nlogn 阶 <code>O(nlogn)</code></li><li>指数阶 <code>O(2^n)</code></li></ul><p>最坏情况和平均情况</p><h3 id="2-5-空间复杂度"><a href="#2-5-空间复杂度" class="headerlink" title="2.5 空间复杂度"></a>2.5 空间复杂度</h3><h2 id="3-线性表"><a href="#3-线性表" class="headerlink" title="3. 线性表"></a>3. 线性表</h2><p>** 定义 **: 0 个或者多个数据元素的 ** 有限序列 **(有限, 有顺序的).</p><p>抽象数据类型的定义:</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">ADT</span> 线性表 <span class="punctuation">(</span><span class="built_in">List</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">Data</span></span><br><span class="line">    线性表的数据对象集合为 <span class="punctuation">&#123;</span><span class="variable">a1</span><span class="operator">,</span><span class="variable">a2</span><span class="operator">,</span><span class="variable">a3</span><span class="operator">,...,</span><span class="variable">an</span><span class="punctuation">&#125;</span><span class="operator">,</span> 每一个元素的类型相同<span class="operator">,</span> 每个元素有且只有一个前驱元素<span class="operator">,</span> 除了最后一个元素<span class="operator">,</span> 每个元素有且只有一个后继元素<span class="operator">.</span> 元素之前的关系是一对一的关系<span class="operator">.</span></span><br><span class="line"><span class="variable">Operation</span></span><br><span class="line">    <span class="variable">InitList</span> 初始化一个新的线性表 <span class="variable">L</span></span><br><span class="line">    <span class="variable">ListEmpty</span> 判空操作</span><br><span class="line">    <span class="variable">ClearList</span> 清空 <span class="built_in">List</span></span><br><span class="line">    <span class="built_in">Get</span><span class="punctuation">(</span><span class="variable">idx</span><span class="punctuation">)</span> 获取指定元素的元素</span><br><span class="line">    <span class="variable">LocateElem</span> 判断是否包含 <span class="variable">element</span></span><br><span class="line">    <span class="built_in">Insert</span> 插入元素</span><br><span class="line">    <span class="built_in">Delete</span> 删除元素</span><br><span class="line">    <span class="variable">Len</span><span class="punctuation">(</span><span class="punctuation">)</span> 获取长度</span><br><span class="line"><span class="variable">endADT</span></span><br></pre></td></tr></table></figure><h3 id="3-2-线性表的-x3D-x3D-顺序-x3D-x3D-存储结构"><a href="#3-2-线性表的-x3D-x3D-顺序-x3D-x3D-存储结构" class="headerlink" title="3.2 线性表的 &#x3D;&#x3D; 顺序 &#x3D;&#x3D; 存储结构"></a>3.2 线性表的 &#x3D;&#x3D; 顺序 &#x3D;&#x3D; 存储结构</h3><p>顺序存储的定义: 是指用一段连续的储存单元依次储存线性表的数据元素.</p><ul><li>一位数组</li></ul><h4 id="x3D-x3D-顺序结构-x3D-x3D-的定义的-3-个属性"><a href="#x3D-x3D-顺序结构-x3D-x3D-的定义的-3-个属性" class="headerlink" title="&#x3D;&#x3D; 顺序结构 &#x3D;&#x3D; 的定义的 3 个属性"></a>&#x3D;&#x3D; 顺序结构 &#x3D;&#x3D; 的定义的 3 个属性</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20  <span class="comment">/* 储存空间初始分配量 */</span></span></span><br><span class="line"></span><br><span class="line">typeof <span class="type">int</span> ElemType; <span class="comment">/*data type*/</span></span><br><span class="line"></span><br><span class="line">typeof <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data&#123;MAXSIZE&#125;; <span class="comment">/* 数据储存的元素的最大值 */</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">/* 当前长度 */</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>定义顺序储存的三个属性:</p><ul><li>储存空间的起始位置, 数组 <code>data</code>, 它的储存位置就是储存空间的储存位置</li><li>线性表的最大储存容量: 数组长度 <code>MAXSIZE</code></li><li>线性表的当前长度: <code>length</code></li></ul><h3 id="3-3-顺序储存结构的插入和删除"><a href="#3-3-顺序储存结构的插入和删除" class="headerlink" title="3.3 顺序储存结构的插入和删除"></a>3.3 顺序储存结构的插入和删除</h3><h4 id="获取操作"><a href="#获取操作" class="headerlink" title="获取操作"></a>获取操作</h4><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>插队操作: <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge73c0qsnhj30oy0f0dm2.jpg"></p><p>插入思路:</p><ol><li><p>插入位置不合理, 抛出异常</p></li><li><p>线性表长度大于或者等于数组长度, 则抛出异常或者 ** 动态扩容 **</p></li><li><p>** 从最后的元素向前遍历到第 <code>i</code> 个元素, 分别将他们向后移动一个位置 **</p></li><li><p>插入的元素插入到位置 <code>i</code> 处</p></li><li><p>** 表长 +1**</p></li></ol><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge73gsp6h4j30qm0gsjxj.jpg"></p><p>删除的操作:</p><ol><li>删除的位置不合理, 抛出异常;</li><li>取出删除的元素</li><li>** 从删除的位置开始遍历到最后一个元素的位置, 分别向前移动一个位置 **</li><li>** 表长 -1**</li></ol><h4 id="优点-amp-缺点"><a href="#优点-amp-缺点" class="headerlink" title="优点 &amp; 缺点"></a>优点 &amp; 缺点</h4><p>优点:</p><ul><li>无序为表中元素之间的逻辑而增加额外的储存空间</li><li>可以快速存取表中的任意位置的元素</li></ul><p>缺点:</p><ul><li>插入, 删除元素需要移动大量的操作</li><li>当线性表长度较大时, 难以确定储存空间的容量</li><li>造成储存空间的 “碎片”</li></ul><h3 id="3-6-线性表的-x3D-x3D-链式-x3D-x3D-存储结构"><a href="#3-6-线性表的-x3D-x3D-链式-x3D-x3D-存储结构" class="headerlink" title="3.6 线性表的 &#x3D;&#x3D; 链式 &#x3D;&#x3D; 存储结构"></a>3.6 线性表的 &#x3D;&#x3D; 链式 &#x3D;&#x3D; 存储结构</h3><p>顺序储存结构的不足: 插入和删除需要移动大量的元素.</p><p>线性表的链式储存结构特点是: 用同一组任意的储存单元储存线性表的数据结构数据, 可以连续, 也可以不连续, 这些数据元素可以存在内存中未被占用的任意位置.</p><p>为了表示每一个数据元素的和下一个元素的逻辑关系, 除了储存本身的信息 (数据域) 之外还要储存一个指示后继元素的信息 (指针域), 这两个数据组合成的称为节点 (Node).</p><p>n 个节点组成一个链表, 即为线性表的链式储存结构, 因为 ** 此节点中的只包含 1 个指针域, 称之为单链表.**</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge7o0dm4szj30tq0a0gom.jpg"></p><ul><li>链表的头结点的存储位置叫做头指针, 最后的节点为 null, 或者 <code>^</code></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge7o1w2gatj30y0092djk.jpg"></p><h3 id="3-7-单链表的读取"><a href="#3-7-单链表的读取" class="headerlink" title="3.7 单链表的读取"></a>3.7 单链表的读取</h3><p>获取第 i 个元素的思路:</p><ol><li>声明一个节点 p 指向链表的第一个节点, 初始化 j 从 1 开始</li><li>当 <code>j &lt; 1</code> 时, 遍历链表, 让 p 的指针向后移动, 不断向指向下一节点, j 累加 1</li><li>若列表的末尾 p 为空, 则说明第 i 个元素存在</li><li>否则查找成功, 返回节点 p 的数据</li></ol><h3 id="3-8-单链表的插入和删除"><a href="#3-8-单链表的插入和删除" class="headerlink" title="3.8  单链表的插入和删除"></a>3.8  单链表的插入和删除</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge7oez2wooj30xm0d8tcr.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next=s</span><br></pre></td></tr></table></figure><p>** 这两个顺序不可以交换 **</p><p>插入顺序:</p><ol><li>声明一节点 p 指向链表的第一个节点, 初始化 j 从 1 开始</li><li>当 j&lt;1 时, 就遍历链表, 让 p 指针向后移动, 不断指向下一阶段, j 累加 1</li><li>若链表末尾 p 为空, 则说明第 i 个元素不存在</li><li>查找成功, 生成一个空节点 s,</li><li>将数据元素 e 赋值给 <code>s-&gt;data</code></li><li>单链表的插入标准语句:<code>s-&gt;next = p-&gt;next; p-&gt;next= s;</code></li><li>返回成功</li></ol><h4 id="3-8-2-单链表的删除"><a href="#3-8-2-单链表的删除" class="headerlink" title="3.8.2 单链表的删除"></a>3.8.2 单链表的删除</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge7ooe3qy4j310o0l4gwd.jpg"></p><p><code>p-&gt;next=p-&gt;next-&gt;next</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br></pre></td></tr></table></figure><p>** 就是让 p 的后继节点的后继节点改为 p 的后继节点.**</p><p>删除顺序:</p><ol><li>声明节点 <code>p</code> 指向链表的第一个节点, 初始化 <code>j</code> 从 1 开始</li><li>当 <code>j &lt; i</code> 时, 就遍历链表, 让 <code>p</code> 的指针向后移动, 不断指向下一个节点, <code>j++</code></li><li>到链表的末尾 <code>p</code> 为空, 则说明第 <code>i</code> 个元素不存在</li><li>否则查找成功, 将要删除的节点 <code>p-&gt;next</code> 赋值给 <code>q</code></li><li>单链表的删除标准语句: <code>p-&gt;next=q-&gt;next;</code></li><li>将 <code>q</code> 节点中的数据赋值给 <code>e</code>, 返回</li><li>释放 <code>q</code> 节点</li><li>返回成功</li></ol><h3 id="3-9-单链表的整表创建"><a href="#3-9-单链表的整表创建" class="headerlink" title="3.9 单链表的整表创建"></a>3.9 单链表的整表创建</h3><p>创建过程就是动态生成链表的过程, 从 “空” 表的初始状态起, 几次建立各个元素节点, 并且逐个插入链表.</p><p>过程:</p><ol><li>声明一节点 <code>p</code> 和计数器变量 <code>i</code></li><li>初始化一个空链表 <code>L</code></li><li>让 <code>L</code> 的头结点指向 <code>NULL</code>, 即建立一个带头结点的单链表</li><li>循环<ol><li>生成一个新的节点赋值给 <code>p</code></li><li>随机生成一个数字复制给 <code>p</code> 的数据域 <code>p-&gt;data</code>;</li><li>将 <code>p</code> 插入到头节点与前一新节点之间</li></ol></li></ol><p>头插法:</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge87j3rp6nj30ze0cwdkd.jpg"></p><p>尾插法:</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge87l3rh2qj30xu082jta.jpg"></p><h3 id="3-10-单链表的整表删除"><a href="#3-10-单链表的整表删除" class="headerlink" title="3.10 单链表的整表删除"></a>3.10 单链表的整表删除</h3><p>思路:</p><ol><li>声明一节点 p 和 q</li><li>将第一节点赋值给 p</li><li>循环<ol><li>将下一节点赋值给 q</li><li>释放 p</li><li>将 q 赋值给 p</li></ol></li></ol><p>两个节点的作用是因为释放一个节点的时候, 把其数据和指向下一个节点的指针也删除了.(p69)</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge87t3ul1lj311209adp4.jpg"></p><h3 id="3-12-静态链表"><a href="#3-12-静态链表" class="headerlink" title="3.12 静态链表"></a>3.12 静态链表</h3><p>数组描述的链表叫静态链表.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge87xp1rz4j30zk0h2wq7.jpg"></p><h3 id="3-13-循环链表"><a href="#3-13-循环链表" class="headerlink" title="3.13 循环链表"></a>3.13 循环链表</h3><p>end -&gt; first</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge883lc6apj30zw0heqa0.jpg"></p><p>循环链表和单链表的主要差异就是 ** 循环的判断条件:**: 原来是判断 <code>p-&gt;next</code> 是否为空, 现在判断是否为头节点, 则循环未结束.</p><p>合并两个循环链表: p80</p><h3 id="3-14-双向链表-double-linked-list"><a href="#3-14-双向链表-double-linked-list" class="headerlink" title="3.14 双向链表 double linked list"></a>3.14 双向链表 double linked list</h3><ul><li><p>插入: 先搞定 s 的前驱和后继, 在搞定后节点的的前驱, 最后解决</p><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge88pzytvtj30yn0u0wxr.jpg"></p></li><li><p>删除:</p></li></ul><h3 id="3-16-总结"><a href="#3-16-总结" class="headerlink" title="3.16 总结"></a>3.16 总结</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge88w1ddk2j30vi0u04qp.jpg"></p><h2 id="4-栈和队列"><a href="#4-栈和队列" class="headerlink" title="4 栈和队列"></a>4 栈和队列</h2><h3 id="4-2-1-栈的定义"><a href="#4-2-1-栈的定义" class="headerlink" title="4.2.1 栈的定义"></a>4.2.1 栈的定义</h3><p>栈是限定在表进行插入和删除的线性表. push and pop.</p><h3 id="4-3-抽象数据类型"><a href="#4-3-抽象数据类型" class="headerlink" title="4.3 抽象数据类型"></a>4.3 抽象数据类型</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ADT 栈 stack</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">    同线性表</span><br><span class="line">Operation</span><br><span class="line">    <span class="built_in">InitStack</span>(*s)</span><br><span class="line">    <span class="built_in">DestroyStack</span>(s)</span><br><span class="line">    <span class="attribute">Clear</span>()</span><br><span class="line">    <span class="built_in">IsEmpty</span>()</span><br><span class="line">    <span class="built_in">gteTop</span>() 获取栈顶元素</span><br><span class="line">    Push</span><br><span class="line">    Pop</span><br><span class="line">    Len</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h3 id="4-5-两个栈共享空间"><a href="#4-5-两个栈共享空间" class="headerlink" title="4.5 两个栈共享空间"></a>4.5 两个栈共享空间</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge9dk13re4j310u0tqwz0.jpg"></p><p><code>top1 + 1 == top2</code> 此时栈满</p><h3 id="4-6-栈的链式储存结构及实现-链栈"><a href="#4-6-栈的链式储存结构及实现-链栈" class="headerlink" title="4.6 栈的链式储存结构及实现 (链栈)"></a>4.6 栈的链式储存结构及实现 (链栈)</h3><p>最好的方法是: 把栈顶放在单链表的头部, 链栈不会出现栈满的状况.</p><h4 id="4-6-2-链栈的进栈操作"><a href="#4-6-2-链栈的进栈操作" class="headerlink" title="4.6.2 链栈的进栈操作"></a>4.6.2 链栈的进栈操作</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge9dvqlyoxj30z40lutdv.jpg"></p><ol><li>把当前栈顶元素赋值给新节点到直接后继</li><li>新节点的结点 s 赋值给栈顶指针</li></ol><h4 id="4-6-3-出栈"><a href="#4-6-3-出栈" class="headerlink" title="4.6.3 出栈"></a>4.6.3 出栈</h4><ol><li>栈顶指针向下移动一位</li><li>最后释放 p 即可</li></ol><h3 id="4-7-栈的作用"><a href="#4-7-栈的作用" class="headerlink" title="4.7 栈的作用"></a>4.7 栈的作用</h3><ul><li><p>递归</p><ul><li>函数自己调用自己.</li><li>必须有至少一个条件, 终止条件.</li><li>怎么使用栈的数据结构: 在前行阶段, 对每一层递归, 函数的局部变量, 参数值和返回地址都被压入栈, 在退回阶段, 位于栈顶的局部变量, 参数值和返回值都 被弹出, 用于返回调用层次中执行代码的其余部分, 恢复了调用的状态.</li></ul></li><li><p>四则运算表达式求值</p></li></ul><h3 id="4-10-对列"><a href="#4-10-对列" class="headerlink" title="4.10 对列"></a>4.10 对列</h3><p>First In First Out</p><h3 id="4-11-ADT"><a href="#4-11-ADT" class="headerlink" title="4.11 ADT"></a>4.11 ADT</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge9eb4ubb4j31060ii4he.jpg"></p><h3 id="4-12-循环对列"><a href="#4-12-循环对列" class="headerlink" title="4.12 循环对列"></a>4.12 循环对列</h3><h4 id="4-12-1-对列顺序储存的不足"><a href="#4-12-1-对列顺序储存的不足" class="headerlink" title="4.12.1 对列顺序储存的不足"></a>4.12.1 对列顺序储存的不足</h4><ul><li>入队: <code>O(1)</code></li><li>出队: <code>O(n)</code></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge9eiodfh4j30zw0jydsp.jpg"><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge9eki1dphj30u00w04mc.jpg"></p><h4 id="4-12-2-循环对列的定义"><a href="#4-12-2-循环对列的定义" class="headerlink" title="4.12.2 循环对列的定义"></a>4.12.2 循环对列的定义</h4><p>收尾相连的顺序储存结构成为循环对列.</p><ul><li>空的条件: <code>front = rear</code></li><li>满的调价: <code>(rear+1)%QueueSize ==  front</code></li></ul><p>定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QElemType data[MAXSIZE],</span><br><span class="line">    <span class="type">int</span> front;  <span class="comment">// 头指针</span></span><br><span class="line">    <span class="type">int</span> rear;   <span class="comment">// 尾指针, 对类不为空, 指向对列尾元素的下一个位置</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><h3 id="4-13-对列的链式储存结构实现"><a href="#4-13-对列的链式储存结构实现" class="headerlink" title="4.13 对列的链式储存结构实现"></a>4.13 对列的链式储存结构实现</h3><p>其实就是线性表的单链表，只不过只能尾进头处。</p><ul><li><p>入队：就是在链表的尾部插入节点</p></li><li><p>出队：头节点的后继节点出队，将头结点的后继节点出队，将头结点的后继改为他后面的阶段，如果链表除了头结点外只剩下一个元素，则需要将 rear 指向头结点。</p><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gebtnolkv6j30yw084q5z.jpg"></p></li></ul><p>在确定队列长度的最大值的情况下，建议使用循环对列，无法预估长度的话，使用链队列。</p><h2 id="5-string"><a href="#5-string" class="headerlink" title="5. string"></a>5. string</h2><h3 id="5-3-串的比较"><a href="#5-3-串的比较" class="headerlink" title="5.3  串的比较"></a>5.3  串的比较</h3><p>串的比较是通过组成串串的字符之间的编码进行的，字符编码指的是字符在对应字符集中的序号。</p><h3 id="5-4-串的抽象数据模型"><a href="#5-4-串的抽象数据模型" class="headerlink" title="5.4 串的抽象数据模型"></a>5.4 串的抽象数据模型</h3><p>关注的是子串的操作</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gebu33n5uij30ve0u04qp.jpg"></p><h3 id="5-5-串的储存结构"><a href="#5-5-串的储存结构" class="headerlink" title="5.5 串的储存结构"></a>5.5 串的储存结构</h3><p><code>\0</code> 常用来表示串的终结。</p><ul><li>顺序储存结构</li><li>链式储存结构</li></ul><h3 id="5-6-朴素的模式匹配算法"><a href="#5-6-朴素的模式匹配算法" class="headerlink" title="5.6 朴素的模式匹配算法"></a>5.6 朴素的模式匹配算法</h3><p>子串的定位操作，通常叫做串的模式匹配</p><p>简单来说就是: 对主串的每一个字符作为子 string 的开头, 和要匹配的字符串进行匹配. 对主串做大循环, 每一个字符开头作为 T 的长度的小循环, 直到匹配成功或者全部变量完成位为止.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegi6oq6agj30u00zzaso.jpg"><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegi6yrkljj31000pidoz.jpg"></p><h3 id="5-7-KMP-模式匹配算法"><a href="#5-7-KMP-模式匹配算法" class="headerlink" title="5.7 KMP 模式匹配算法"></a>5.7 KMP 模式匹配算法</h3><h4 id="5-7-1-基本原理"><a href="#5-7-1-基本原理" class="headerlink" title="5.7.1 基本原理"></a>5.7.1 基本原理</h4><p>TODO until page 148</p><h2 id="6-树🌲"><a href="#6-树🌲" class="headerlink" title="6 树🌲"></a>6 树🌲</h2><p>树是 n(n≥0) 个有限节点的有限集. n &#x3D; 0 时候称为空树. 在人一个非空树中:</p><ol><li>有且只有一个称为根 (Root) 的节点;</li><li>当 n&gt;1 的时候, 其余节点可以分为 m(m&gt;0) 个 ** 互不相交的 ** 有限集, 其中每一个集合本身又是一颗树, 并且为根的子树 (SubTree).</li></ol><p>注意:</p><ul><li>根节点是唯一的</li><li>m&gt;0 时候, 子树一定是 ** 不相交 ** 的.</li></ul><h4 id="6-2-1-节点分类"><a href="#6-2-1-节点分类" class="headerlink" title="6.2.1 节点分类"></a>6.2.1 节点分类</h4><ul><li><p>节点的度: 节点拥有子树的数量称为节点的度 (Degree)</p></li><li><p>度为 0 的节点称为叶节点 (Leaf) 或者终端节点</p></li><li><p>度不为 0 的节点称为非终端节点或者分支节点</p></li><li><p>树的度是内部节点的度的最大值.</p><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegiuq4ryoj30zk0okdt9.jpg"></p></li></ul><h4 id="6-2-2-节点的关系"><a href="#6-2-2-节点的关系" class="headerlink" title="6.2.2 节点的关系"></a>6.2.2 节点的关系</h4><ul><li>节点的子树称为该节点的 Child</li><li>该节点称为孩子的双亲 (Parent)</li><li>同一个双亲的孩子之间称为 sibling</li><li>节点的祖先就是从根到该节点所经历分支上的所有节点.<h4 id="6-2-3-其他概念"><a href="#6-2-3-其他概念" class="headerlink" title="6.2.3 其他概念"></a>6.2.3 其他概念</h4></li><li>层次 level 从根开始计算, 根为第一层.</li><li>Depth: 深度或者高度: 树中节点的最大层次称为树的深度.</li><li>有序树: 各个子树从左到右是有次序的, 不能互换的, 则称为有序树, 否则为无序树</li></ul><h3 id="6-3-树的抽象数据模型"><a href="#6-3-树的抽象数据模型" class="headerlink" title="6.3 树的抽象数据模型"></a>6.3 树的抽象数据模型</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehdax3p7uj30yw0u04qp.jpg"></p><h3 id="6-4-树的储存结构"><a href="#6-4-树的储存结构" class="headerlink" title="6.4 树的储存结构"></a>6.4 树的储存结构</h3><h4 id="6-4-1-双亲表示法"><a href="#6-4-1-双亲表示法" class="headerlink" title="6.4.1 双亲表示法"></a>6.4.1 双亲表示法</h4><p>除了根节点之外, 其余的每个节点, 不一定有孩子, 但是一定有且仅有一个双亲.</p><p>假设一组连续的空间储存树的节点, 同时在每一个节点中附加一个指示器指示其 parent 的节点到链表中的位置 (每个节点除了知道自己的位置还知道双亲在哪里)</p><table><thead><tr><th>data</th><th>parent</th></tr></thead></table><p>data 为数据域, parent 为指针域.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TYPE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> TElemType; <span class="comment">/* 树性节点的数据类型, 整型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data; <span class="comment">// 节点数据</span></span><br><span class="line">    <span class="type">int</span> parent;     <span class="comment">// 双亲位置</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TYPE_SIZE]; <span class="comment">// 节点数组</span></span><br><span class="line">    <span class="type">int</span> r, n;                    <span class="comment">// 根的位置和节点树</span></span><br><span class="line">&#125; PTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于根节点是没有双亲的, 所以约定根节点的位置域设置为 -1;</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehecdewg6j31160s6wll.jpg"></p><p>这样的话:</p><ol><li>可以根据节点的 parent 指针找到他的双亲节点,<code>O(1)</code>，直到 parent 为 - 1。</li><li>想要直到节点的孩子是什么却只能遍历</li></ol><p>麻烦，增加一个节点最左边的域，称之为长子域，这样就很容易得到节点的孩子。如果没有孩子的节点，长子域就是 - 1。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehidwj562j30fc0bu41o.jpg"></p><p>为了关注兄弟之间的关系，双亲表示没法体现这样的关系，增加一个右边兄弟域来体现兄弟关系，如果有兄弟就记录下右兄弟的下标，否则为 - 1。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehiwokwzlj30g60cagp4.jpg"></p><h4 id="6-4-2-孩子表示法"><a href="#6-4-2-孩子表示法" class="headerlink" title="6.4.2 孩子表示法"></a>6.4.2 孩子表示法</h4><p>把每一个节点放到一个顺序储存结构的数组中是合理的，但是每一个节点有多少个孩子是不确定的，所以我们再对每个节点的孩子建立一个单链表来体现这种关系。</p><p>具体方法就是：** 把每个节点的孩子节点排列起来，以单链表作为储存结构，则 n 个节点有 n 个孩子链表，如果是叶子节点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序储存结构，放入一个一位数组中去。**</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehjbnp6fkj30zs0jo7b3.jpg"></p><p>需要设计两种结构：一种是孩子链表的的子节点：</p><table><thead><tr><th>child</th><th>next</th></tr></thead><tbody><tr><td>child 是数据域，用来储存某个节点在表头数组的下标。next 是指针域，用来储存指向某节点的下一个孩子的节点的指针。</td><td></td></tr></tbody></table><p>另外一个是表头数组的表头节点，</p><table><thead><tr><th>data</th><th>first child</th></tr></thead></table><p>data 是数据域，某个节点的数据信息，firstchild 是头指针域，储存该节点的孩子链表的头指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 孩子节点 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; * ChildPtr;</span><br><span class="line"><span class="comment">/* 表头结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125; CTBox;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 树结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TYPE_SIZE];</span><br><span class="line">    <span class="type">int</span> r, n;</span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure><p>这样的结构对于我们要查找某个节点的子孩子，或者兄弟来说，只需要查找到这个节点的孩子的单链表即可，遍历整个树仅仅需要对头节点的数组循环即可。</p><p>但是无法知道 parent，这时候可以添加一个 parent 指针：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehjtklo9wj30so0k4q91.jpg"></p><p>双亲孩子表示法。</p><h4 id="6-4-3-孩子兄弟表示法"><a href="#6-4-3-孩子兄弟表示法" class="headerlink" title="6.4.3 孩子兄弟表示法"></a>6.4.3 孩子兄弟表示法</h4><p>任意一棵树🌲他的节点的第一个孩子如果存在就是唯一的，如果他的右兄弟如果存在也是唯一的。因此设置两个指针，分别指向该节点的第一个和此节点的右兄弟。</p><table><thead><tr><th>data</th><th>firstchild</th><th>rightsib</th></tr></thead></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">rightsib</span>;</span></span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehkvtwteij30nw0mmq8d.jpg"></p><h3 id="6-5-二叉树-Binary-Tree"><a href="#6-5-二叉树-Binary-Tree" class="headerlink" title="6.5 二叉树 Binary Tree"></a>6.5 二叉树 Binary Tree</h3><p>定义： Binary Tree 是 n≥0 个节点的有限集合，该集合或者为空集，或者为一个根节点和两颗互不相交的、分别为根节点的子树和右子树的二叉树组成的。</p><h4 id="6-5-1-二叉树的特点"><a href="#6-5-1-二叉树的特点" class="headerlink" title="6.5.1 二叉树的特点"></a>6.5.1 二叉树的特点</h4><ul><li><p>每个节点 ** 最多 ** 有两棵子树，所以二叉树中不存在度大于 2 的节点。</p></li><li><p>左子树和右子树是有顺序的，次序不能颠倒。</p></li><li><p>即使树中某个节点只有一个子树，也要区分它是左子树还是右子树。</p></li></ul><p>二叉树具有 5 种基本形态：</p><ol><li>空二叉树</li><li>只有一个根节点</li><li>根节点只有左子树</li><li>根节点只有右子树</li><li>根节点既有左子树又有右子树</li></ol><h4 id="6-5-2-特殊二叉树"><a href="#6-5-2-特殊二叉树" class="headerlink" title="6.5.2 特殊二叉树"></a>6.5.2 特殊二叉树</h4><ol><li><p>斜树：所有的节点都只有左子树的二叉树叫做左斜树，同理右斜树。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehm4cy4fjj313e0bmwi7.jpg"></p><p>线性表就是树的一种特殊的表现形式</p></li><li><p>满二叉树：所有的分支结构都存在左子树和右子树，并且所有的叶子节点都在同一层上。</p><p> <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehm7cmylkj30je09qjtr.jpg"></p><p> 满二叉树的特点：</p><ol><li>叶子在最下面一层</li><li>非叶子节点的度一定是 2</li><li>在同样深度的二叉树中，满二叉树的节点个数最多，叶子最多。</li></ol></li><li><p>完全二叉树：对同一棵具有 n 个节点的二叉树按 ** 照层序编号 **，如果编号为 i(1≤i≤n) 的节点和同样深的的 ** 满二叉树 ** 中编号为 i 的节点在二叉树中的位置完全相同，则这颗二叉树称为完全二叉树。</p><p> <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehmcecpzzj30ju0bq418.jpg"></p><p> 完全二叉树的特点：</p><ol><li>叶子节点只能出现在最下面两层</li><li>最下面的叶子一定集中在左部连续位置</li><li>倒数二层，若有叶子节点，一定在右部连续位置</li><li>如果节点的度为 1，则该节点只有做孩子，不存在只有右子树的情况</li><li>同样节点树的二叉树，完全二叉树的深度最下</li></ol></li></ol><h3 id="6-2-二叉树的性质"><a href="#6-2-二叉树的性质" class="headerlink" title="6.2 二叉树的性质"></a>6.2 二叉树的性质</h3><ol><li><p>二叉树的第 i 层上至多有 $2^{i-1}$ 个节点 (i≥1)</p></li><li><p>深度为 k 的二叉树至多有 $2^k-1$ 个节点 (k≥1)</p></li><li><p>对任意一颗二叉树 T，如果其终端节点数为 $n_0$, 度为 2 的节点数为 $n_2$, 则 $n_0$ &#x3D; $n_2$ $+1$</p><p> <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehnuci9gij30yk0u0tr6.jpg"></p></li><li><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehnw9cr0oj30zu0380uo.jpg"></p></li><li><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehnxm90xfj30u00yakfa.jpg"></p></li></ol><h3 id="6-7-二叉树的储存结构"><a href="#6-7-二叉树的储存结构" class="headerlink" title="6.7 二叉树的储存结构"></a>6.7 二叉树的储存结构</h3><h4 id="6-7-1-二叉树的顺序储存结构"><a href="#6-7-1-二叉树的顺序储存结构" class="headerlink" title="6.7.1 二叉树的顺序储存结构"></a>6.7.1 二叉树的顺序储存结构</h4><p>二叉树是一种特殊的树，可以使用顺序储存结构实现。就是使用一位数组储存二叉树中的节点，并且节点的储存位置，也就是数组的下标要能体现节点间的逻辑关系，双亲和孩子，兄弟之间的关系。</p><ul><li><p>完全二叉树<br>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geho2a7unzj310k0pgk1k.jpg"></p></li><li><p>一般二叉树</p><p>  层序编号不能反应逻辑关系，但是可以按照完全二叉树编号，把不存在的节点设置为 <code>^</code></p><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geho5shxioj30og0ic42y.jpg"></p></li><li><p>极端情况</p><p>  深度为 k 的树，只有 k 个节点，斜树，但是分配空间很多，浪费资源。所以顺序储存的结构一般仅仅用于完全二叉树。</p><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geho7ob90xj30x80eiq85.jpg"></p></li></ul><h4 id="6-7-2-二叉链表"><a href="#6-7-2-二叉链表" class="headerlink" title="6.7.2 二叉链表"></a>6.7.2 二叉链表</h4><p>二叉树每个节点最多只有两个孩子，所以设计一个数据域和两个指针域，这样的链表称之为二叉链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉链表 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehoghuqt9j31040n8wn7.jpg"></p><h3 id="6-8-遍历二叉树-Traversing-Binary-Tree"><a href="#6-8-遍历二叉树-Traversing-Binary-Tree" class="headerlink" title="6.8 遍历二叉树 Traversing Binary Tree"></a>6.8 遍历二叉树 Traversing Binary Tree</h3><h4 id="6-8-1-原理"><a href="#6-8-1-原理" class="headerlink" title="6.8.1 原理"></a>6.8.1 原理</h4><p>定义： 是指从二叉树的根节点出发，按照某种次序依次访问二叉树中所有的节点，使得每个节点被访问仅仅一次。</p><p>⚠️：访问和次序。</p><h4 id="6-8-2-遍历方法"><a href="#6-8-2-遍历方法" class="headerlink" title="6.8.2 遍历方法"></a>6.8.2 遍历方法</h4><ol><li><p>前序遍历</p><p> 如果二叉树为空，则返回，否则先访问根节点，然后前序遍历左子树，再前序遍历右子树。ABDGHCEIF</p><p> <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehsvyxouqj30bw0biacq.jpg"></p></li><li><p>中序遍历</p><p> 若树为空，则返回，否则从根节点开始，不是先访问根节点，中序遍历根节点的左子树，然后访问根节点，最后中序遍历右子树。</p><p> <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geht2m5mwaj30ku0cc77k.jpg"></p></li><li><p>后序遍历</p><p> 空，返回。否则先从左到右先叶子后节点的方式访问左右子树，最后遍历根节点。</p><p> <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geht50i4v5j30bm0cq76v.jpg"></p></li><li><p>层序遍历</p><p> 为空，则返回。否则从第一层，从上到下，从左到右逐渐访问。</p><p> <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geht8l97lwj30ca0cg413.jpg"></p></li></ol><h3 id="6-8-3-前序遍历算法-p181"><a href="#6-8-3-前序遍历算法-p181" class="headerlink" title="6.8.3 前序遍历算法 p181"></a>6.8.3 前序遍历算法 p181</h3><p>二叉树的定义是递归定义的。遍历算法可以采用递归。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraverse</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">    PreOrderTraverse(T-&gt;lchild); <span class="comment">// 左子树</span></span><br><span class="line">    PreOrderTraverse(T-&gt;rchild); <span class="comment">// 右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-8-4-中序遍历算法"><a href="#6-8-4-中序遍历算法" class="headerlink" title="6.8.4 中序遍历算法"></a>6.8.4 中序遍历算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    InOrderTraverse(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">    InOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-8-5-后序遍历算法"><a href="#6-8-5-后序遍历算法" class="headerlink" title="6.8.5 后序遍历算法"></a>6.8.5 后序遍历算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderTraverse</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    PostOrderTraverse(T-&gt;lchild);</span><br><span class="line">    PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-8-6-推导遍历结果-p184"><a href="#6-8-6-推导遍历结果-p184" class="headerlink" title="6.8.6 推导遍历结果 p184"></a>6.8.6 推导遍历结果 p184</h3><p>Q：前序遍历为 ABCDEF, 中序遍历结果 CBAEDF, 求后续遍历结果？</p><p>A：三种遍历都是先从根节点开始，前序是先打印在递归左和右。A 是根节点。<br>中序遍历序列可以知道 C、B 的左子树的节点，E、D、F 是 A 的右子树。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehv21h30jj30z60u01a1.jpg"></p><p>遍历二叉树的性质：</p><ul><li><p>已知前序遍历序列和中序遍历序列，可以确定唯一棵二叉棵树。</p></li><li><p>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</p></li><li><p>仅仅知道前序和后续不能唯一确定一棵二叉树。</p><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehv72a73hj30zq0din6c.jpg"></p></li></ul><h3 id="6-9-二叉树的建立"><a href="#6-9-二叉树的建立" class="headerlink" title="6.9 二叉树的建立"></a>6.9 二叉树的建立</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehveffh7rj31060oo4ed.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateBiTree</span><span class="params">(BiTree *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    TElemType ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        <span class="keyword">if</span> (!*T)</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">        CreateBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也是利用了递归的原理。只不过在打印的地方变成了生成节点。</p><h3 id="6-10-线索二叉树"><a href="#6-10-线索二叉树" class="headerlink" title="6.10 线索二叉树"></a>6.10 线索二叉树</h3><h4 id="6-10-1-线索二叉树原理"><a href="#6-10-1-线索二叉树原理" class="headerlink" title="6.10.1 线索二叉树原理"></a>6.10.1 线索二叉树原理</h4><p>为了节约没有用到的空的指针域。把这种前驱和后继的指针称为线索，加上线索的二叉链表称之为线索链表，相应的二叉树就称之为线索二叉树。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geiknz7bg8j30zk0l2tko.jpg"></p><p>对二叉树以某种次序遍历时期变为线索二叉树的过程称为线索化。</p><p>线索化的过程就是在遍历的过程种修改空指针的问题</p><p>通过 lchild&#x2F;rchild 指向他的左 &#x2F; 右孩子还是前驱 &#x2F; 后继？</p><p>添加一个区分的标示：</p><p>节点结构：</p><table><thead><tr><th>lchild</th><th>ltag</th><th>data</th><th>rtag</th><th>rchild</th></tr></thead></table><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geimex8ldej30wm0jin57.jpg"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树储存结构实现</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Link,</span><br><span class="line">    Thread</span><br><span class="line">&#125; PointerTag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    PointerTag LTag;</span><br><span class="line">    PointerTag RTag;</span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>线索化的实质就是将二叉树链表中的空指针改为指向前驱或者后继的线索。而前驱和后继信息只能在遍历的时候才能获得，所以线索化的过程就是在遍历的过程中修改空指针的过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历线索化的递归函数</span></span><br><span class="line">BiThrTree pre; <span class="comment">// 全局变量，一直指向刚访问的节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThreading</span><span class="params">(BiThrTree p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        InThreading(p-&gt;lchild); <span class="comment">// 递归左子树线索化</span></span><br><span class="line">        <span class="comment">// no left child</span></span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;lchild)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;LTag = Thread; <span class="comment">// 前驱线索</span></span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// no right child</span></span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;RTag = Thread;</span><br><span class="line">            pre-&gt;rchild = p; <span class="comment">// 前驱右孩子指针指向后继（当前节点为 p）</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = p; <span class="comment">// mark</span></span><br><span class="line">        InThreading(p-&gt;rchild); <span class="comment">// 递归右子树线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和中序遍历只有两处不同：</p><ol><li>mark 处</li><li>将打印节点改成了线索化的功能</li></ol><p><code>pre = p</code> 实际的做的是：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geiqak0e1lj31240c4aln.jpg"></p><p>现在遍历时发现，其实就是操作一个双向链表结构。p193</p><h3 id="6-13-树、森林和二叉树的转换"><a href="#6-13-树、森林和二叉树的转换" class="headerlink" title="6.13 树、森林和二叉树的转换"></a>6.13 树、森林和二叉树的转换</h3><h4 id="6-13-1-树转化为二叉树"><a href="#6-13-1-树转化为二叉树" class="headerlink" title="6.13.1 树转化为二叉树"></a>6.13.1 树转化为二叉树</h4><p>步骤：</p><ol><li>加线，sibling 之间</li><li>去线，只保留他和第一个孩子的连线，删除它和其他孩子之间的线</li><li>旋转，根节点为轴心，将树顺时针旋转一定的角度，使得层次分明。（孩子是二叉树的左孩子，兄弟是右孩子）</li></ol><h4 id="6-13-2-森林转化为二叉树"><a href="#6-13-2-森林转化为二叉树" class="headerlink" title="6.13.2 森林转化为二叉树"></a>6.13.2 森林转化为二叉树</h4><p>步骤：</p><ol><li><p>每个树转换为二叉树</p></li><li><p>第一个二叉树保持不动，第二个树开始，依次把后一棵二叉树的根作为前一个二叉树的根节点的右孩子，涌现出来链接起来。</p><p> <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geiqvgtphbj30y40u0du3.jpg"></p></li></ol><h3 id="6-13-3-二叉树转化为树"><a href="#6-13-3-二叉树转化为树" class="headerlink" title="6.13.3 二叉树转化为树"></a>6.13.3 二叉树转化为树</h3><p>树转化为二叉树的逆序：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geir0w3b5oj30u014p4ew.jpg"></p><h3 id="6-13-4-二叉树转化为森林"><a href="#6-13-4-二叉树转化为森林" class="headerlink" title="6.13.4 二叉树转化为森林"></a>6.13.4 二叉树转化为森林</h3><p>判断能够转化为一棵树还是森林：就看 ** 根节点有没有右孩子 **，有就是森林，没有就是一棵树🌲。</p><p>步骤：从根开始</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geit7wuxrkj310m0ceqcp.jpg"></p><h3 id="6-12-赫夫曼树和应用"><a href="#6-12-赫夫曼树和应用" class="headerlink" title="6.12 赫夫曼树和应用"></a>6.12 赫夫曼树和应用</h3><h3 id="6-12-1-2-赫夫曼树、定义与原理"><a href="#6-12-1-2-赫夫曼树、定义与原理" class="headerlink" title="6.12.1-2 赫夫曼树、定义与原理"></a>6.12.1-2 赫夫曼树、定义与原理</h3><p>最基本的压缩算法：赫夫曼编码。</p><ul><li>路径长度</li><li>路径</li><li>带权路径的长度</li><li>霍夫曼树</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geitjhmc4fj30u00zi4qp.jpg"></p><p>二叉树 a 的 WPL：$5<em>1+15</em>2+40<em>3+30</em>4+10*4 &#x3D; 315$</p><p>怎么构造出最优的赫夫曼树呢？<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geitpz5a1dj30u00z14kz.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geitrtejmkj30u00wwe5w.jpg"></p><h4 id="6-12-3-赫夫曼编码"><a href="#6-12-3-赫夫曼编码" class="headerlink" title="6.12.3 赫夫曼编码"></a>6.12.3 赫夫曼编码</h4><p>主要是为了解决当年远距离通信（主要是电报）的数据传输的最优化问题。</p><ul><li><p>编码<br>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geitxu2jm2j30u014h4qp.jpg"></p></li><li><p>解码</p><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geitz6nxlvj30u00zo1kx.jpg"></p></li></ul><h3 id="6-12-4-🌲总结"><a href="#6-12-4-🌲总结" class="headerlink" title="6.12.4 🌲总结"></a>6.12.4 🌲总结</h3><ul><li>树定义：递归在树定义的使用；子树｜节点｜度｜叶子｜分支节点｜双亲｜孩子｜层次｜深度｜森林</li><li>储存结构：双亲表示法｜孩子表示法｜孩子兄弟表示法</li><li>二叉树<ul><li>每个节点最多两个子树，有左右之分。斜树｜满二叉树｜完全二叉树</li><li>二叉树性质</li><li>二叉树的储存结构：链式｜顺序结构</li><li>遍历：前序｜中序｜后续 （递归）</li><li>构造一棵二叉树，线索二叉树</li><li>树和森林的转化</li><li>应用：赫夫曼编码｜赫夫曼树</li></ul></li></ul><h2 id="7-图"><a href="#7-图" class="headerlink" title="7. 图"></a>7. 图</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gej4x888r4j30u00xgtwr.jpg"></p><p>Later</p><h2 id="8-查找-Search"><a href="#8-查找-Search" class="headerlink" title="8. 查找 Search"></a>8. 查找 Search</h2><h3 id="8-2-查找概论"><a href="#8-2-查找概论" class="headerlink" title="8.2 查找概论"></a>8.2 查找概论</h3><ul><li>查找表（Search Table）是由 ** 同一类类型 ** 的数据元素构成的集合。</li><li>关键字（Key）就是可以唯一标示一个元素或则记录的关键字，次关键字是（Secondary Key）</li><li>查找就是（Searching）就是根据给定的某个值，在查找表中确定找到一个其关键字等于给定值的数据元素（或者记录）</li></ul><p>查找表的分类：</p><ul><li>静态查找表: 只做查找操作的查找表</li><li>动态查找表: 在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经删除已经存在的某个数据元素</li></ul><h3 id="8-3-顺序查找表"><a href="#8-3-顺序查找表" class="headerlink" title="8.3 顺序查找表"></a>8.3 顺序查找表</h3><p>顺序查找（Sequence Search）又叫线性查找，是最基本的查找技术，过程就是：从第一个遍历查找。（<code>java.util.Iterator</code>）</p><p>顺序查找的算法： <code>for 循环 </code></p><p>顺序查找的查找优化：**🎯哨兵机制 **</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 哨兵机制 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Better_Sequential_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    a[<span class="number">0</span>] = key; <span class="comment">// 设置 a[0] 为关键字，我们称之为 “哨兵”</span></span><br><span class="line">    i = n;      <span class="comment">// 循环从数组尾部开始</span></span><br><span class="line">    <span class="keyword">while</span> (a[i] != key)</span><br><span class="line">    &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// 返回 0 表示数组查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-有序表查找"><a href="#8-4-有序表查找" class="headerlink" title="8.4 有序表查找"></a>8.4 有序表查找</h3><h4 id="8-4-1-折半查找（二分查找）"><a href="#8-4-1-折半查找（二分查找）" class="headerlink" title="8.4.1 折半查找（二分查找）"></a>8.4.1 折半查找（二分查找）</h4><p>前提是线性表中的关键字 ** 有序 **，线性表必须采用 ** 顺序储存 **。折半的基本思想是：在有序表中，去中间记录作为比较对象，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录大于记录的关键字，则在中间记录的右半区继续查找。</p><p>Code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 折半查找 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low, high, mid;</span><br><span class="line">    low = <span class="number">1</span>;</span><br><span class="line">    high = n;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid])</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key&gt; a[mid])</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(log_n)$</li></ul><h3 id="8-4-2-插值查找"><a href="#8-4-2-插值查找" class="headerlink" title="8.4.2 插值查找"></a>8.4.2 插值查找</h3><p>折半查找的改进空间：折半查找的代码中，关键的是：</p><p>$mid&#x3D;\frac{low+high}{2} &#x3D; low +\frac{1}{2}(high-low)$, 也就是 mid 等于下标 $low$ 加上 $high$ 与 $low$ 的一半，算法科学家就是考虑将这个 $\frac{1}{2}$, 改为下面的计算方案：$mid &#x3D; low + \frac{key-a[low]}{a[high]-a[low]}(high-low)$，将 $\frac{1}{2}$ 改为 $\frac{key-a[low]}{a[high]-a[low]}$ 道理就是减少折半的次数, 提高效率。</p><p>插值查找（Interpolation Search）是根据查找的关键字 key 与查找表中最大最小记录的关键字比较后的查找方式，其核心在插值计算共识: $\frac{key - a[low]}{a[high]-a[low]}$。</p><h3 id="8-4-3-斐波那契查找"><a href="#8-4-3-斐波那契查找" class="headerlink" title="8.4.3 斐波那契查找"></a>8.4.3 斐波那契查找</h3><p>TODO</p><h3 id="8-5-线性索引查找"><a href="#8-5-线性索引查找" class="headerlink" title="8.5 线性索引查找"></a>8.5 线性索引查找</h3><p>实际搜索中全部记录无法保证某个关键字有序。</p><p>数据结构的最终目的是提高数据的处理速度，** 索引 ** 是为了加快查找速度而设计的一种数据结构。** 索引就是把一个关键字和它对应的记录关联的过程！** 索引至少由若干 ** 索引项 ** 构成，每个索引项至少包含 ** 关键字 ** 和对应的记录在 ** 储存器 ** 中的位置信息。</p><p>索引的分类：</p><ul><li><p>线性索引</p><p>  线性索引就是将索引项集合组织为线性结构，也称为索引表。主要有下面三种：</p><ol><li>稠密索引</li><li>分块索引</li><li>倒排索引</li></ol></li><li><p>树形索引</p></li><li><p>多级索引</p></li></ul><h4 id="8-5-1-稠密索引"><a href="#8-5-1-稠密索引" class="headerlink" title="8.5.1 稠密索引"></a>8.5.1 稠密索引</h4><p>稠密索引就是将数据集中的每条记录对应一个索引项。对于稠密索引这个索引表来说，索引项一定是按照关键码的有序排列。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gek9wn6czjj30oi0hetf4.jpg"></p><ul><li><p>优点：索引项有序，在查找关键字的时候可以用到查找、插值、斐波那契的有序查找算法，效率很高。</p></li><li><p>缺点：数据集很大的时候，就是索引也会很大。</p></li></ul><h3 id="8-5-2-分块索引"><a href="#8-5-2-分块索引" class="headerlink" title="8.5.2 分块索引"></a>8.5.2 分块索引</h3><p>类似图书管的藏书方法。</p><p>分块排序就是，把数据集记录分成了若干片，这些片满足两个条件：</p><ol><li>块 ** 内 ** 无序</li><li>块 ** 间 ** 有序</li></ol><p>分块索引的索引项分为三个数据项：</p><ol><li>对于分块有序的数据集，它储存每一块中的最大关键字，这样的好处就是可以 ** 下一块中的最小关键字也能比这一块的最大关键字也要大；**</li><li>储存块中的记录个数，以便可以♻️循环使用；</li><li>指向块首元素的指针，对块中的这一块的记录📝进行遍历。</li></ol><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gekab1dcuij30om0su7bl.jpg"></p><p>在分块索引表中查找，分 2⃣️步进行：</p><ol><li>在分块索引中查找查找关键字所在的块。有序 -&gt; 可以折半、插值</li><li>根据块首的指针找到相应的块，在块中找到关键字。</li></ol><p>分块索引索在兼顾了对块不需要有序的情况下，大大增加了整体查找的速度，普遍用在数据库的查找等技术。</p><h3 id="8-5-3-倒排索引"><a href="#8-5-3-倒排索引" class="headerlink" title="8.5.3 倒排索引"></a>8.5.3 倒排索引</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gelfmjzqy6j30c40cwwhb.jpg"><br>这里的单词表就是索引表，索引项的通用结构就是：</p><ul><li>次关键码，上面的英文单词；</li><li>记录号表，上面的文章编号；</li></ul><p>记录表储存具有相同次关键词的所有记录号，这样的索引方法就是倒排索引（inverted index）</p><p>为什么叫倒排索引：现实生活中通常需要根据属性（字段、次关键码）的值来查找记录，这种索引表中的每一项都包含一个属性值和具有该属性值的各个记录的地址。** 不是通过记录来确定属性值，而是通过属性值来确定记录的位置，索引称为倒排索引🎭**</p><p>优点：查找快，生成索引表后，查找时都不用读取记录，就可以得到结果。<br>缺点：记录号不定长，每个单词都可能有相当多的文章编号，维护困难。插入和删除都需要左相应的处理。</p><h3 id="8-6-二叉排序树"><a href="#8-6-二叉排序树" class="headerlink" title="8.6 二叉排序树"></a>8.6 二叉排序树</h3><p>Binary Sort Tree：是一棵空树，或者具有下面性质的二叉树：</p><ol><li>若它的左子树不空，则左子树上所有的值均小于它根节点的值；</li><li>若它的右子树不空，则右子树上所有的值均大于它根节点的值；</li><li>它的左右子树分别为二叉排序🌲；</li></ol><p>二叉排序树的目的不是为了排序，而是为了 ** 查找和删除关键字的速度 **</p><h4 id="8-6-1-二叉排序树查找操作"><a href="#8-6-1-二叉排序树查找操作" class="headerlink" title="8.6.1 二叉排序树查找操作"></a>8.6.1 二叉排序树查找操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SearchBST */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;                        <span class="comment">// node data</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">// left or right chile ptr</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">SearchBST</span><span class="params">(BiTree T, <span class="type">int</span> key, BiTree f, BiTree *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="comment">// not found</span></span><br><span class="line">    &#123;</span><br><span class="line">        *p = f;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key == T-&gt;data) <span class="comment">// found</span></span><br><span class="line">    &#123;</span><br><span class="line">        *p = T;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild, key, T, p); <span class="comment">// keep finding in left son tree</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild, key, T, p); <span class="comment">// keep finding in right son tree</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>参数 T 为一个二叉链表，key 表示要找的关键字 (p318)</li></ol><h4 id="8-6-2-二叉排序树插入操作"><a href="#8-6-2-二叉排序树插入操作" class="headerlink" title="8.6.2 二叉排序树插入操作"></a>8.6.2 二叉排序树插入操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*BTS insert ops*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertBTS</span><span class="params">(BiTree *T, <span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTree p, s;</span><br><span class="line">    <span class="keyword">if</span> (!SearchBST(*T, key, <span class="literal">NULL</span>, &amp;p)) <span class="comment">// find nothing</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        s-&gt;data = key;</span><br><span class="line">        s-&gt;lchild = s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">        &#123;</span><br><span class="line">            *T = s; <span class="comment">//insert the new node as root node</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; p-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;lchild = s; <span class="comment">// insert as the left child</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;rchild = s; <span class="comment">// insert as the right child</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// already has the same node, do not insert</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geodyvwbyzj31440lagv7.jpg"></p><h4 id="8-6-3-二叉排序树的删除操作"><a href="#8-6-3-二叉排序树的删除操作" class="headerlink" title="8.6.3 二叉排序树的删除操作"></a>8.6.3 二叉排序树的删除操作</h4><ul><li>删除叶子🍃直接删除就行了</li><li>要删除的节点只有左子树、右子树也好办，就是将他的左子树和右子树整个移动到节点的位置就行了。结果还是一个二叉排序树。</li><li>当删除的节点既有左子树，又有又子树的情况下<ul><li>可以删除这个节点，然后挨个把他的子节点插入进去，但是可能会使得树的高度增加，NOT OK</li><li>比较好的方法是：找到要删除节点 p 的直接前驱（或直接后继）s，用 s 来替换 p，然后在删除掉 s（Page 324）</li></ul></li></ul><h4 id="8-6-4-二叉排序树的总结"><a href="#8-6-4-二叉排序树的总结" class="headerlink" title="8.6.4 二叉排序树的总结"></a>8.6.4 二叉排序树的总结</h4><p>二叉排序树是以链接的方式储存，保持了链接储存结构在执行插入或者插入操作不用移动元素的优点，只需要找到合适的插入和删除位置之后，仅仅需要修改链接指针即可。</p><p>二叉排序树的查找性能取决于二叉排序树的形状。 问题就是二叉排序树的形状是不确定的。</p><h3 id="8-7-平衡二叉树（AVL-树）"><a href="#8-7-平衡二叉树（AVL-树）" class="headerlink" title="8.7 平衡二叉树（AVL 树）"></a>8.7 平衡二叉树（AVL 树）</h3><p>平衡二叉树（Self-Balancing Binary Search Tree ｜ Height-Balanced Binary Search Tree）是一种二叉排序树，每个节点的左子树和右子树高度至多等于 1.</p><p>为什么叫 AVL 树是因为俄罗斯🇷🇺两个科学家名字的简称：$G.M.Adelson-Velskii$ + $E.M.Landis$</p><ul><li>这是一种高度平衡的树，高度平衡是因为：要么是空树，要没左子树和右子树都是平衡二叉树，且深度之差的绝对值不超过 1</li><li>将二叉树上节点的左子树减去右子树的深度的值称为 平衡因子 BF（Balance Factor）</li><li>平衡因子只能为 0，-1，+1</li></ul><p>平衡二叉树的定义的前提是一棵二叉排序树。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geotnh9bqjj312q0kwait.jpg"></p><ul><li>距离插入点最近的，并且平衡因子的绝对值大于 1 的节点为根的子树，称之为最小不平衡子树。</li></ul><h4 id="8-7-1-平衡二叉树的实现原理"><a href="#8-7-1-平衡二叉树的实现原理" class="headerlink" title="8.7.1 平衡二叉树的实现原理"></a>8.7.1 平衡二叉树的实现原理</h4><p>平衡二叉树的构建的基本思想就是在构建二叉排序树的过程中，每当插入一个节点的时候，先检查是否因为插入而破坏了树的平衡性。如果破坏了的话就找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中节点之间的连接关系，进行相应的旋转，使之称为新的平衡子树。</p><p>BF 为负数，左旋，正数，右旋</p><p>例子： 对于数组 <code>a[10] =&#123;3,2,1,4,5,6,7,10,9,8&#125;</code></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geotz6d9iij314q0oetpe.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geotzwxta2j315y0p2k6o.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geou4sipphj310k0u0dw1.jpg"></p><h4 id="8-7-1-平衡二叉树的实现算法"><a href="#8-7-1-平衡二叉树的实现算法" class="headerlink" title="8.7.1 平衡二叉树的实现算法"></a>8.7.1 平衡二叉树的实现算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平衡二叉树</span></span><br><span class="line"><span class="comment">// 二叉树的二叉链表节点的结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;                        <span class="comment">//  data of the node</span></span><br><span class="line">    <span class="type">int</span> balanceFactor;               <span class="comment">// balance factor</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> <span class="comment">// left and right child</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋  对以 p 为根的二叉排序树进行右旋处理</span></span><br><span class="line"><span class="comment">// 处理之后 p 指向新的树根节点，即 旋转处理之前的左子树的根节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">R_Rotate</span><span class="params">(BiTree *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTree L;</span><br><span class="line">    L = (*p)-&gt;lchild;         <span class="comment">// L 指向 P 左子树根节点</span></span><br><span class="line">    (*p)-&gt;lchild = L-&gt;rchild; <span class="comment">//L 的右子树挂接为 P 的左子树</span></span><br><span class="line">    L-&gt;rchild = (*p);</span><br><span class="line">    *p = L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geouj2ihcgj31340mmaop.jpg"></p><p>左旋</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">L_Rotate</span><span class="params">(BiTree *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTree R;</span><br><span class="line">    R = (*p)-&gt;rchild;</span><br><span class="line">    (*p)-&gt;rchild = R-&gt;lchild;</span><br><span class="line">    R-&gt;lchild = (*p);</span><br><span class="line">    *p = R;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TODO</p><ul><li>主函数 insertAVL</li><li>左平衡旋转处理的函数处理</li></ul><h3 id="8-8-多路查找树（B-树🌲）"><a href="#8-8-多路查找树（B-树🌲）" class="headerlink" title="8.8 多路查找树（B 树🌲）"></a>8.8 多路查找树（B 树🌲）</h3><p>如果操作的数据集非常大，关于时间复杂度的计算就会发生变化，访问该集合元素的时间已经不仅仅是寻找该元素所需要比较次数的函数，** 必须考虑对硬盘等外部储存设备的访问时间以及对高该设备做出了多少此单独访问。**</p><p>一旦涉及到外部储存设备，** 关于时间的复杂度的计算就会发生变化 **，访问该集合元素的时间已经不仅仅是寻找该元素所需比较次数的函数，我们必须考虑 ** 对外部储存设备的访问时间 ** 以及 ** 作出多少次单次访问的问题 **。</p><p>以前谈的树都是，一个节点可以有多个孩子，但是本身值储存一个元素，二叉树的限制更多，节点只能有两个孩子。</p><p>一个节点只能有一个元素，在元素非常多的时候，就是的树的度非常大（节点拥有子树的最大值），要么树的的高度非常大，甚至使得二者都很大。这就是的内存存取外存的次数很多，成了时间上的瓶颈。为此引入了多路查找树的概念（一个节点能有多个数据）</p><p>多路查找树（muitl-way search tree）每一个节点的孩子树可以多余两个，并且每一个节点处可以储存多个元素。</p><h4 id="8-8-1-2-3-树"><a href="#8-8-1-2-3-树" class="headerlink" title="8.8.1 2-3 树"></a>8.8.1 2-3 树</h4><ul><li><p>2-3 树：每一个节点都具有两个孩子，称之为 2 节点，或者 3 个三个孩子。</p></li><li><p>一个 2 节点包含一个元素和两个孩子（或者没有孩子），且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。 不过和二叉排序树不同的是：这个 2 节点要么没有孩子，要么有两个，不能只有一个孩子。</p></li><li><p>一个 3 节点包含一大一小的两个元素和三个孩子。要么没有孩子，要没 3 个孩子，左孩子小于该节点，右孩子大于该节点，中间孩子介于两个元素之间。</p></li><li><p>所有的 2-3 树中所有的叶子都在同一个节点层次上。</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geovtmhlxhj31680hsqb8.jpg"></p><p>难在删除和插入节点带来的复杂连锁反应。</p><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><ul><li><p>对于空树，只需要插入 2 节点就可以了</p></li><li><p>插入节点到 2 节点的叶子上。应该说，由于本身就有一个元素，所以 将其升级为 3 节点即可。要比较插入的元素和当前叶子节点的元素比较大小，决定谁在左谁在右。</p><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geowove83ij316s084gqf.jpg"></p></li><li><p>往 3 节点中插入元素。因为 3 节点本身已经是 2-3 树中节点容量最大容量，此时就需要将其拆分，且将树中的两个元素或者插入元素中选择其一向上移动一层。</p><ul><li><p>第一种情况：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geowy2t633j313q0jwnc1.jpg"></p></li><li><p>第二种情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geox1gycv8j313c0ia17o.jpg"></p></li><li><p>第三种情况：<br>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geox3fmji9j30xu0u0h34.jpg"></p></li></ul></li></ul><p>如果 2-3 树插入的传播效应导致了根节点的拆分，则树的高度会增加。</p><h5 id="2-3-树的删除"><a href="#2-3-树的删除" class="headerlink" title="2-3 树的删除"></a>2-3 树的删除</h5><ul><li>删除 3 节点的话，直接删除可以</li><li>删除 2 节点上分为四种情况处理：<ul><li>节点双亲也是 2 节点，且有一个 3 个节点的右孩子；</li><li>节点双亲是 2 节点，有一个右孩子也是一个 2 节点；</li><li>双亲 3 节点</li><li>当前树为一棵慢二叉树，删除任何一个叶子节点都会使得整个树不满足 2-3 树的定义</li></ul></li></ul><h4 id="8-8-2-2-3-4-树"><a href="#8-8-2-2-3-4-树" class="headerlink" title="8.8.2 2-3-4 树"></a>8.8.2 2-3-4 树</h4><p>就是 2-3 树的的扩展概念，一个 4 个节点包含了小中大三个元素个 4 个孩子（或者没有孩子），子树从中的数据从左到右一次变大。</p><h4 id="8-8-3-B-树"><a href="#8-8-3-B-树" class="headerlink" title="8.8.3 B 树"></a>8.8.3 B 树</h4><p>B 树（B-Tree）是一种平衡的多路查找树，2-3｜2-3-4 树都是 B 树的特例。节点最大的孩子数目称为 B 树的阶（order）</p><p>如果一个树的阶数为 m，则：</p><ol><li>根节点如果不是叶子节点，那么至少有两个子树</li><li>所有的叶子节点都位于同一层次上</li><li>每个节点至多有 m 个子节点</li><li>每个节点最多有 m-1 个 key，并且以升序排列</li></ol><p>实际使用中，B 树的阶树很大，通常大于 100，使得树的高度不会很高。</p><ul><li><p>B 树上的查找过程是顺指针查找节点，和在节点中查找关键字的过程。</p></li><li><p>B 树的作用：** 减少内存和外存的数据次数交换 **，怎么做的呢？</p><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geqjhw550yj313e0swu0m.jpg"></p></li><li><p>对于 n 个关键字，m 阶的树最坏的情况是什么？</p><p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geqjjejk1qj313s0hagyq.jpg"></p></li></ul><h4 id="8-8-3-B-树-1"><a href="#8-8-3-B-树-1" class="headerlink" title="8.8.3 B+ 树"></a>8.8.3 B+ 树</h4><p>B 树的缺陷：遍历 B 树的时候需要大量的和硬盘之间的页面进行交互。</p><p>B + 树是应文件系统所需而出现的一种 B 树的变形树，严格来说已经不是一种树了。在 B 树中，每一个元素在该树中仅仅出现一次，可能在叶子上，也有可能在分支节点上。</p><p>但是在 B + 树中，出现在分支节点中的元素会被当作它们在分支位置中的后继者（叶子节点）中再次列出。每一个叶子节点都会保存一个指向后一个叶子节点的指针。</p><ul><li>关键字在叶子节点中再次列出，并且所有的叶子节点链接在一起。*</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geqmjeturfj30ry09676j.jpg"></p><p>一棵 m 阶的 B + 树和 m 阶的 B 树的区别：</p><ol><li>有 n 棵子树的节点包含 n 个关键字</li><li>所有的叶子节点包含全部关键字的信息，以及指向这些关键字记录的指针，** 叶子节点本身关键字的大小从小到大顺序链接 **</li><li>所有的分支节点可以看出 ** 索引 **，节点中仅仅包含其子树中最大（或者最小）关键字</li></ol><p>B+🌲的好处：</p><ol><li><p>如果 ** 随机查找 **：就从根节点出发，和 B 树的查找方式相同，只不过即使子啊分支节点找到了待查找的关键字，也只是用来 ** 索引 ** 的，还是需要到达包含次关键字的重点。</p></li><li><p>如果从最小关键字到最大关键字（从小到大）进行顺序查找：我们就从最左侧的叶子出发，* 不经过分支节点，而是沿着指向下一个叶子的指针就可以遍历所有的关键字。*</p></li></ol><p>B+ 树比较适合带有范围的查找。比如查找 18-22 岁学生的人数，可以通过 ** 根节点出发 ** 查找第一个 18 节点的学生，然后再在叶子节点 ** 按照顺序查找符合范围 ** 的全部记录。</p><h3 id="8-9-散列表查找（hash-table）"><a href="#8-9-散列表查找（hash-table）" class="headerlink" title="8.9 散列表查找（hash-table）"></a>8.9 散列表查找（hash-table）</h3><table><thead><tr><th align="left">无序查找</th><th align="left">有序查找</th></tr></thead><tbody><tr><td align="left">挨个查找</td><td align="left">折半、插值</td></tr></tbody></table><h4 id="8-9-1-散列表的定义"><a href="#8-9-1-散列表的定义" class="headerlink" title="8.9.1 散列表的定义"></a>8.9.1 散列表的定义</h4><p>$$ 储存位置 &#x3D; f（关键字）$$</p><p>查找关键字不需要通过比较就可以获得记录的位置，这就是新的储存技术。</p><p>** 散列技术 **：是在记录的储存位置和它的关键字之间建立一种特定的对应关系 <code>f</code>, 使得每个关键字 key 对应一个储存位置 <code>f(key)</code></p><p>这种对应关系 f 称为散列函数，又称为 ** 哈希函数 (Hash) 函数 **。</p><p>采用散列技术将记录储存在一块连续的存储空间中，这块连续储存空间被称为散列表，或者 ** 哈希表 **（Hash Table）</p><h4 id="8-9-2-散列表的查找步骤"><a href="#8-9-2-散列表的查找步骤" class="headerlink" title="8.9.2 散列表的查找步骤"></a>8.9.2 散列表的查找步骤</h4><p>整个散列过程其实就是两步：</p><ol><li>在储存的时候，通过计算散列函数计算记录的散列地址，并且按照此散列地址储存该记录；</li><li>在查找记录的时候，我们同样的散列函数计算记录的散列地址，按照此地址访问该记录。</li></ol><p>** 散列技术即是一种储存方法，又是一种查找方法。** 散列主要是面向查找的储存结构。</p><p>散列技术最适合的求解问题是查找与给定值相等的记录。</p><p>散列函数应该如何设计？</p><ul><li>简单、均匀、储存利用率高</li><li>问题 1 是冲突：通常就是 $key1≠key2$，但是 $f(key1) &#x3D; f(key2)$, 这种现象就是冲突。并且把 $key1 &amp; key2$ 称为这个散列函数的同义词。</li></ul><h2 id="8-10-散列函数的构造方法"><a href="#8-10-散列函数的构造方法" class="headerlink" title="8.10 散列函数的构造方法"></a>8.10 散列函数的构造方法</h2><ol><li>计算简单</li><li>散列地址分布均匀</li></ol><h4 id="8-10-1-直接定址法"><a href="#8-10-1-直接定址法" class="headerlink" title="8.10.1 直接定址法"></a>8.10.1 直接定址法</h4><p>取关键字某个线性地址为散列地址，$f(key) &#x3D; a*key+b(a,b 为常数)$</p><h4 id="8-10-2-数字分析法"><a href="#8-10-2-数字分析法" class="headerlink" title="8.10.2 数字分析法"></a>8.10.2 数字分析法</h4><p>抽取方法就是：使用关键字的一部分来计算储存位置的方法（抽取的数字是和其他记录不同的）来计算散列储存的。</p><h4 id="8-10-3-平方取中"><a href="#8-10-3-平方取中" class="headerlink" title="8.10.3 平方取中"></a>8.10.3 平方取中</h4><p>一个数平方后在取中间的几位数字作为散列地址。</p><h4 id="8-10-4-折叠法"><a href="#8-10-4-折叠法" class="headerlink" title="8.10.4 折叠法"></a>8.10.4 折叠法</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ger43dozxxj314s0hanbq.jpg"></p><h4 id="8-10-5-除留余数法"><a href="#8-10-5-除留余数法" class="headerlink" title="8.10.5 除留余数法"></a>8.10.5 除留余数法</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ger45e787hj313e0pu1bp.jpg"></p><h4 id="8-10-6-随机数法"><a href="#8-10-6-随机数法" class="headerlink" title="8.10.6 随机数法"></a>8.10.6 随机数法</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ger473rm6cj315q0ryat1.jpg"></p><h3 id="8-11-处理散列冲突的方法"><a href="#8-11-处理散列冲突的方法" class="headerlink" title="8.11 处理散列冲突的方法"></a>8.11 处理散列冲突的方法</h3><h4 id="8-11-1-开放定定址法"><a href="#8-11-1-开放定定址法" class="headerlink" title="8.11.1 开放定定址法"></a>8.11.1 开放定定址法</h4><p>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的位置总能找到，然后插入。</p><p>$f_i(key) &#x3D; ((f(key)+d_i) MOD m(d_i&#x3D;1,2,3,4…m-1)$</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ger4fia923j31440mg184.jpg"></p><p>** 我们把这种解决冲突的开放定址法称为线性探测法。**</p><p>本来不是同义词却需要争夺同一地址的情况，称之为堆积。</p><ul><li><p>随机探测法：在冲突的时候对于位移量 $d_i$ 随机函数计算的到，称之为随机探测法</p><p>  $f_1(key) &#x3D; (f(key)+d_i) MOD m(d_i 是一个随机数列)$</p></li></ul><p>总之开发定址法只要在散列表未填满时，总能找到不发生冲突地址，是我们用来解决冲突的方法。</p><h4 id="8-11-2-再散列函数法"><a href="#8-11-2-再散列函数法" class="headerlink" title="8.11.2 再散列函数法"></a>8.11.2 再散列函数法</h4><p>$f_i(key) &#x3D; RH_1(key) (i&#x3D; 1,2,…k)$,$RH_1$ 就是不同的散列函数，发生冲突的时候就换一个散列函数计算。</p><h4 id="8-11-3-链地址法"><a href="#8-11-3-链地址法" class="headerlink" title="8.11.3 链地址法"></a>8.11.3 链地址法</h4><p>将所有的关键字为同义词的记录储存在一个单链表中，我们称这种表为同义词子表，在散列表中只储存所有同义词字表的头指针。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ger5al1zz1j30ja0q0gq2.jpg"></p><ul><li>不会出现找不到地址的情况</li><li>查找时带来了需要遍历单链表的性能损耗</li></ul><h4 id="8-11-4-公共溢出区法"><a href="#8-11-4-公共溢出区法" class="headerlink" title="8.11.4 公共溢出区法"></a>8.11.4 公共溢出区法</h4><p>为所有冲突的关键字建立了一个公共存放的溢出区来存放。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ger5ftcppgj30bw0sijw1.jpg"></p><p>查找的时候，通过给定的值计算散列地址后，先后与基本表的相应位置进行对比，如果成功，则查找成功；如果不想等，则到溢出表中进行 ** 顺序 ** 查找。</p><h3 id="8-12-散列表查找实现"><a href="#8-12-散列表查找实现" class="headerlink" title="8.12 散列表查找实现"></a>8.12 散列表查找实现</h3><h3 id="8-12-2-散列表的查找性能分析"><a href="#8-12-2-散列表的查找性能分析" class="headerlink" title="8.12.2 散列表的查找性能分析"></a>8.12.2 散列表的查找性能分析</h3><ul><li>散列函数是否均匀（影响产生冲突的可能性）</li><li>处理冲突的方法（不同的冲突的解决方法）</li><li>🏵散列表的装填 a 因为：所谓的装填因子就是 &#x3D; 填入表中的记录个数 &#x2F; 散列表的长度。</li><li>a 越大，越容易产生冲突</li><li>通常将散列表的空间设置得比查找集合大，虽然浪费一定的空间，但是查找的效率大大提升。</li></ul><h3 id="8-13-总结回顾"><a href="#8-13-总结回顾" class="headerlink" title="8.13 总结回顾"></a>8.13 总结回顾</h3><p>围绕 “查找” 主体</p><p>概念：查找表｜记录｜关键字｜主关键字｜静态查找表｜动态查找表｜</p><ul><li>顺序查找表：哨兵机制</li><li>有序查找：折半｜插值｜斐波那契查找</li><li>线性索引查找：稠密索引、分块索引、倒排索引。广泛引用在文件搜索、数据库、搜索引擎等领域技术。</li><li>二叉排序树：** 最重要的数据类型 **，可以在兼顾性能的情况下，让插入和删除效率也变得比较高。不过为了到达最优秀的状态，二叉排序树平衡后才最佳，AVL 平衡二叉树。</li><li>B 树是为了针对 ** 内存和外存 ** 之间的存取而专门设计的。由于内外存的查找性能更多取决于读取的次数，因此需要考虑 B 树的平衡和层次。2-3 树 &#x3D;&gt; 2-3-4 树 &#x3D;&gt; B 树 &#x3D;&gt; B + 树</li><li>散列表是一种非常高效的查找的数据结构。</li></ul><h2 id="9-排序"><a href="#9-排序" class="headerlink" title="9. 排序"></a>9. 排序</h2><p>定义：是使得记录按照某个关键字有序的操作。</p><ul><li>排序的稳定性</li></ul><h4 id="9-2-2-内排序和外排序（Bubble-Sort）"><a href="#9-2-2-内排序和外排序（Bubble-Sort）" class="headerlink" title="9.2.2 内排序和外排序（Bubble Sort）"></a>9.2.2 内排序和外排序（Bubble Sort）</h4><ul><li>内排序：整个排序过程中，带排序的所有记录全部被放在内存中。</li><li>外排序：数据太多，需要内外存之间多次交换数据。</li></ul><p>内排序受 3 方面的影响：</p><ol><li>时间性能，内排序的操作往往需要：比较和移动，减少比较次数和移动次数。</li><li>辅助空间：除了待排序的数据额外需要的数据。</li><li>算法的复杂性，指的是算法本身的复杂度，而不是算法的时间复杂度。</li></ol><p>常见的 7 种算法：</p><ul><li>简单排序：冒泡排序｜简单选择排序｜简单插入排序</li><li>改进算法：希尔排序｜堆排序｜归并排序｜快速排序</li></ul><h3 id="冒泡排序-最简单的排序实现"><a href="#冒泡排序-最简单的排序实现" class="headerlink" title="冒泡排序 - 最简单的排序实现"></a>冒泡排序 - 最简单的排序实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For sort</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> r[MAXSIZE + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; SqList;</span><br><span class="line"><span class="comment">// 封装交换算法</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(SqList *L, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp = L-&gt;r[i];</span><br><span class="line">    L-&gt;r[i] = L-&gt;r[j];</span><br><span class="line">    L-&gt;r[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基本的冒泡算法 (效率很低)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort0</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// !! notice here</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt; L-&gt;length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (L-&gt;r[i] &gt; L-&gt;r[j])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(L, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-3-2-冒泡排序算法"><a href="#9-3-2-冒泡排序算法" class="headerlink" title="9.3.2 冒泡排序算法"></a>9.3.2 冒泡排序算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// j 是从后向前循环 (⚠️)</span></span><br><span class="line">        <span class="keyword">for</span> (j = L-&gt;length - <span class="number">1</span>; j &gt;= i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若前者大于后者</span></span><br><span class="line">            <span class="keyword">if</span> (L-&gt;r[j] &gt; L-&gt;r[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(L, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gerqoj8jcaj30zc0u0qtg.jpg"></p><h3 id="9-3-3-冒泡排序的优化"><a href="#9-3-3-冒泡排序的优化" class="headerlink" title="9.3.3 冒泡排序的优化"></a>9.3.3 冒泡排序的优化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免局部有序的排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSortAdv</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    Status flag = TRUE;</span><br><span class="line">    <span class="comment">// 如果 flag 为 true 退出循环</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; L-&gt;length &amp;&amp; flag; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化 flag 为 false</span></span><br><span class="line">        flag = FLASE;</span><br><span class="line">        <span class="comment">// j 是从后向前循环</span></span><br><span class="line">        <span class="keyword">for</span> (j &lt; L-&gt;length - <span class="number">1</span>; j &gt;= i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若前者大于后者</span></span><br><span class="line">            <span class="keyword">if</span> (L-&gt;r[j] &gt; L-&gt;r[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(L, j, j + <span class="number">1</span>);</span><br><span class="line">                flag = TRUE; <span class="comment">// 有数据交换就设置 flag 为 true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-3-3-冒泡排序复杂度分析"><a href="#9-3-3-冒泡排序复杂度分析" class="headerlink" title="9.3.3 冒泡排序复杂度分析"></a>9.3.3 冒泡排序复杂度分析</h4><p>$$O(n^2)$$</p><p><img src="https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp" alt="pic"></p><h3 id="9-4-简单的选择排序（Simple-Selection-Sort）"><a href="#9-4-简单的选择排序（Simple-Selection-Sort）" class="headerlink" title="9.4 简单的选择排序（Simple Selection Sort）"></a>9.4 简单的选择排序（Simple Selection Sort）</h3><ul><li>冒泡排序：短线交易</li><li>选择排序：长线交易</li></ul><h4 id="9-4-1-简单选择排序算法-p384"><a href="#9-4-1-简单选择排序算法-p384" class="headerlink" title="9.4.1 简单选择排序算法 (p384)"></a>9.4.1 简单选择排序算法 (p384)</h4><p>** 先标记，找到最小的，然后在交换。**</p><p>简单选择排序算法: 就是通过 <code>n-1</code> 次关键字之间的比较，从 <code>n-i+1</code> 个记录中选出关键词最小的记录，并和第 <code>i(1 ≤ i ≤ n</code> 个记录交换之。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, min;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将当前下标定义为最小值下标</span></span><br><span class="line">        min = i;</span><br><span class="line">        <span class="comment">// 循环之后的数据</span></span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= L-&gt;length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  如果有小于当前最小值的关键字</span></span><br><span class="line">            <span class="keyword">if</span> (L-&gt;r[min] &gt; L-&gt;r[j])</span><br><span class="line">            &#123;</span><br><span class="line">                min = j; <span class="comment">// 将此关键字的下标赋值给 min</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != min) <span class="comment">// 如果 min 不等于 i 说明找到了最小值 交换</span></span><br><span class="line">            &#123;</span><br><span class="line">                swap(L, i, min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 $$O(n^2)$$</p><p><img src="https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp" alt="pic"></p><h3 id="9-5-直接插入排序"><a href="#9-5-直接插入排序" class="headerlink" title="9.5 直接插入排序"></a>9.5 直接插入排序</h3><h3 id="9-5-1-直接插入算法-Straight-Insertion-Sort"><a href="#9-5-1-直接插入算法-Straight-Insertion-Sort" class="headerlink" title="9.5.1 直接插入算法 (Straight Insertion Sort)"></a>9.5.1 直接插入算法 (Straight Insertion Sort)</h3><p>联想扑克牌插入排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="comment">// 从 2 开始</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= L-&gt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (L-&gt;r[i] &lt; L-&gt;r[i - <span class="number">1</span>]) <span class="comment">/* 需要将 L-&gt;r[i] 插入有序列表 */</span></span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;r[<span class="number">0</span>] = L-&gt;r[i]; <span class="comment">// 设置哨兵</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; L-&gt;r[j] &gt; L-&gt;r[<span class="number">0</span>]; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                L-&gt;r[j + <span class="number">1</span>] = L-&gt;r[j]; <span class="comment">// 记录后移动</span></span><br><span class="line">                L-&gt;r[j + <span class="number">1</span>] = L-&gt;r[<span class="number">0</span>]; <span class="comment">// 插入到正确的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" alt="pic"></p><p>时间复杂度同样是 $O(n^2)$, 性能比冒泡和简单排序的性能好一些。</p><h3 id="9-6-希尔排序（Shell-Sort）"><a href="#9-6-希尔排序（Shell-Sort）" class="headerlink" title="9.6 希尔排序（Shell Sort）"></a>9.6 希尔排序（Shell Sort）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> increment = L-&gt;length;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        increment = increment / <span class="number">3</span> + <span class="number">1</span>; <span class="comment">// 增量序列</span></span><br><span class="line">        <span class="keyword">for</span> (i = increment + <span class="number">1</span>; i &lt; L-&gt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (L-&gt;r[i] &lt; L-&gt;r[i - increment])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 需要将 L-&gt;r[i] 插入有序增量字表</span></span><br><span class="line">                L-&gt;r[<span class="number">0</span>] = L-&gt;r[i]; <span class="comment">// 暂存在 L-&gt;r[0]</span></span><br><span class="line">                <span class="keyword">for</span> (j = i - increment; j&gt; <span class="number">0</span> &amp;&amp; L-&gt;r[<span class="number">0</span>] &lt; L-&gt;r[j]; j -= increment)</span><br><span class="line">                &#123;</span><br><span class="line">                    L-&gt;r[j + increment] = L-&gt;r[j]; <span class="comment">// 记录后移 查找插入位置</span></span><br><span class="line">                    L-&gt;r[j + increment] = L-&gt;r[<span class="number">0</span>]; <span class="comment">// 插入</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (increment&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-6-3-Shell-Sort-的时间复杂度的分析"><a href="#9-6-3-Shell-Sort-的时间复杂度的分析" class="headerlink" title="9.6.3 Shell Sort 的时间复杂度的分析"></a>9.6.3 Shell Sort 的时间复杂度的分析</h4><p>Shell Sort 的关键: 并不是随便分组后各自排序,** 而是将相隔某一个 “增量” 记录成一个子序列 **, 实现跳跃式的移动.</p><ul><li>增量序列的最后一个增量值必须等于 1 才行;</li><li>由于记录是跳跃式的移动, 希尔排序不是一 ** 种稳定的排序算法 **.</li></ul><p>时间复杂度： $O(n^\frac{3}{2})$</p><h3 id="9-7-堆排序-Heap-Sort"><a href="#9-7-堆排序-Heap-Sort" class="headerlink" title="9.7 堆排序 Heap Sort"></a>9.7 堆排序 Heap Sort</h3><p>前面提到的简单选择排序, <em>没有一个把结果保存下来, 在后一趟的比较中, 前面已经做过了, 但是前面没有保存, 还要重新进行操作.</em></p><p>堆也是一种数据结构.</p><p>堆是具有下面性质的 ** 完全二叉树 **: 每个节点的值都要大于或者等于其左右孩子节点的值, 成为大顶堆; 每个节点的值都要小于或者等于其左右孩子节点的值, 称为小顶堆.</p><ul><li>根节点一定是最大 &#x2F; 最小的</li></ul><h4 id="9-7-1-堆排序算法"><a href="#9-7-1-堆排序算法" class="headerlink" title="9.7.1 堆排序算法"></a>9.7.1 堆排序算法</h4><p>基本思想就是: 将待排序的序列构成一个大顶堆, 此时整个序列最大的值就是堆顶的根节点. 将它移走 (** 其实就是堆数组的末尾元素交换, 此时整个末尾元素就是最大值 **), 然后将剩余的 <code>n-1</code> 个序列重新构成一个堆, 这样就会得到 n 个元素中次小的值. 如此反复执行, 就得到一个有序序列.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gewz3cfx3lj31340jsqgu.jpg"><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gewz42arocj30yi0cutcg.jpg"></p><p>实现它需要两个问题:</p><ol><li>如何由一个无序序列构建成一个堆?</li><li>怎么在输出堆顶后, 将调整元素成为一个新的堆?</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Heap Sort</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 把 L 中的 r 构建成一个大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (i = L-&gt;length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        HeapAdjust(L, i, L-&gt;length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = L-&gt;length; i &gt; <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(L, <span class="number">1</span>, i);           <span class="comment">// 将堆顶记录和当前未排序子序列的最后一个记录交换</span></span><br><span class="line">        HeapAdjust(L, <span class="number">1</span>, i - <span class="number">1</span>); <span class="comment">// 将 L-&gt;[1..i-1] 重新调整为大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一个循环要完成的就是讲现在的待排序序列构建为一个大顶堆</li><li>逐步将每个最大的值的根节点与末尾元素交换, 并且在调整为其成为大顶堆</li></ul><p>假如要排序的是:<code>&#123;50,10,90,30,70,40,80,60,20&#125;</code>, 那么 <code>L-&gt;length=9</code>, 第一个 <code>for</code> 循环,<code>i</code> 从 <code>[9/2]=4</code> 开始,<code>4-&gt;3-&gt;2-&gt;1</code> 变量变化, 为什么不是从 <code>1-9</code>, 而是 <code>4-&gt;1</code> 呢, 从下面的图可以看出,** 他们都是有孩子的节点 **, 下表编号就是 1,2,3,4.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gewzptrcxyj30hq0ai76l.jpg"></p><p>所谓的将待排序的序列构建成一个大顶堆,** 其实就是从下到上, 从右到左, 将每个非终端节点 (非叶子节点) 当做节点, 将其和其子树调整成大顶堆. i 的 <code>4-&gt;3-&gt;2-&gt;1</code> 的变量变化, 其实就是 30,90,10,50 节点的调整过程.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已知 L-&gt;r[s..m] 中记录的关键字除了 L-&gt;r[s] 之外满足堆的定义</span></span><br><span class="line"><span class="comment">// 本函数调整 L-&gt;r[s] 的关键字, 使 L-&gt;r[s..m] 成为一个大顶堆</span></span><br><span class="line"><span class="comment">// 注释是第一次循环</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapAdjust</span><span class="params">(SqList *L, <span class="type">int</span> s, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp, j;</span><br><span class="line">    temp = L-&gt;r[s];</span><br><span class="line">    <span class="comment">// j 的左孩子是 2*s, 右孩子是 2*s+1, 因此 j 变量也是这样才是循环的</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span> * s; j &lt; m; j *= <span class="number">2</span>) <span class="comment">// 沿关键字较大的孩子节点向下筛选</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// j 小于 m 说明不是最后一个节点, L-&gt;r[j] &lt; L-&gt;r[j + 1] 说明左孩子小于右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; m &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ++j; <span class="comment">// j 为关键字中最大记录的下标 (目标是找到找到最大值, 指向右下标)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp&gt;= L-&gt;r[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// temp = 30, 不满足条件 L.r[j]=60</span></span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;r[s] = L-&gt;r[j]; <span class="comment">// 以 30 为根节点的子二叉树</span></span><br><span class="line">        s = j;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;r[s] = temp; <span class="comment">// 完成 30 和 60 的交换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gex0d1fnwbj3126046act.jpg"><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gex0oekh6aj30u010w1kx.jpg"><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gex0oz137nj30zw0u0thm.jpg"><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gex0q3zpg1j311c0pgwrq.jpg"><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gex0qvvp3tj30u013stt6.jpg"><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gex0r7wa5zj311808a78q.jpg"><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gex0rm8x0uj313c03uwh7.jpg"></p><p>接下来 HeapSort 的函数 6~11 行就是正式排序过程.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=L-&gt;length;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">    swap(L,l,i)          <span class="comment">// 将堆顶记录和当前未经排序子序列的最后的一个记录交换</span></span><br><span class="line">    HeapAdjust(L,<span class="number">1</span>,i<span class="number">-1</span>); <span class="comment">// 将 L-&gt;r[1..i-1] 重新调整为最大堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化: <code>&#123;50,10,90,30,70,40,80,60,20&#125;</code></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gex0yi8vkfj30u80u0h8j.jpg"><br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gex1216eq9j30u00y17py.jpg"></p><h4 id="9-7-2-堆排序算法-时间复杂度"><a href="#9-7-2-堆排序算法-时间复杂度" class="headerlink" title="9.7.2 堆排序算法 - 时间复杂度"></a>9.7.2 堆排序算法 - 时间复杂度</h4><p>堆排序主要消耗在 ** 初始构建堆 ** 和 ** 重新构建堆时候的反复筛选上 **</p><ul><li>构建堆的时间复杂度为:$O(n)$</li><li>重建堆的时间复杂度为:$O(nlogn)$</li></ul><p>堆排序的时间复杂度为: $O(nlogn)$</p><h3 id="9-8-归并排序-Merging-Sort"><a href="#9-8-归并排序-Merging-Sort" class="headerlink" title="9.8 归并排序 (Merging Sort)"></a>9.8 归并排序 (Merging Sort)</h3><p>完全二叉树排序的算法.<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gex1gqblt2j31940m8wwf.jpg"></p><p>** 归并排序 **: 假设初始含有 n 个元素, 则可以看成 n 个有序的字序列, 每个子序列的长度为 1, 然后两两归并, 得到 <code>[n/2]</code> 个长度为 2 或者 1 的有序子序列; 再次两两归并, 如此重复, 直到得到一个长度为 <code>n</code> 的有序序列位置, 这种排序方法为 2 路归并排序.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Merge Sort SR[s..t] 归并为 TR1[s..t]</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    MSort(L-&gt;r, L-&gt;r, <span class="number">1</span>, L-&gt;length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 SR[s...t]</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MSort</span><span class="params">(<span class="type">int</span> SR[], <span class="type">int</span> TR1[], <span class="type">int</span> s, <span class="type">int</span> t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">int</span> TR2[MAXSIZE + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (s == t)</span><br><span class="line">    &#123;</span><br><span class="line">        TR1[s] = SR[s];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m = (s + t) / <span class="number">2</span>;          <span class="comment">// 将 SR[s..t] 平分为 SR[s..m] 和 SR[m+1..t]</span></span><br><span class="line">        MSort(SR, TR2, s, m);     <span class="comment">// 递归将 SR[s..m] 归并为有序的 TR2[s..m]</span></span><br><span class="line">        MSort(SR, TR2, m + <span class="number">1</span>, t); <span class="comment">// 递归将 SR[m+1..t] 归并为有序的 TR2[m+1..t];</span></span><br><span class="line">        Merge(TR2, TR1, s, m, t); <span class="comment">// 将 TR2[s..m] and TR2[m+1..t]</span></span><br><span class="line">        <span class="comment">// merge to TR1[s..t]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Merge SR[i..m] and SR[m+1..n] to ordered TR[i..n]</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> SR[], <span class="type">int</span> TR[], <span class="type">int</span> i, <span class="type">int</span> m, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j, k, l;</span><br><span class="line">    <span class="keyword">for</span> (j = m + <span class="number">1</span>, k = i; i &lt; m &amp;&amp; j &lt; n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (SR[i] &lt; SR[j])</span><br><span class="line">            TR[k] = SR[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TR[k] = SR[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (l = <span class="number">0</span>; l &lt;= m - i; l++)</span><br><span class="line">            TR[k + <span class="number">1</span>] = SR[i + <span class="number">1</span>]; <span class="comment">// copy the rest SR[i..m] to TR</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (l = <span class="number">0</span>; l &lt;= n - j; l++)</span><br><span class="line">            TR[k + <span class="number">1</span>] = SR[j + <span class="number">1</span>]; <span class="comment">// copy the rest of SR[j..n] to TR</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Steps:</p><ol><li>Divide the array to two array, recursively to the each array with only two elements</li><li>Sort the tow array in to new array temp</li><li>Copy the temp array to origin array</li></ol><h4 id="9-8-2-时间复杂度分析"><a href="#9-8-2-时间复杂度分析" class="headerlink" title="9.8.2 时间复杂度分析"></a>9.8.2 时间复杂度分析</h4><p>时间复杂度:</p><ol><li>一趟递归并需要将 SR[1]<del>SR[n] 中相邻的长度为 h 的有序序列进行两两归并, 并且将结果复制到 TR1[1]</del>TR1[n] 中, 需要将待排序的序列中扫描一遍, 耗费 <code>O(n)</code></li><li>由完全二叉树的深度可以知道, 整个归并排序需要进行 $log_2n$, 总的时间复杂度 $O(nlogn)$</li></ol><p>空间复杂度:</p><ul><li>有序归并排序在归并过程中需要与原始序列同样数量的储存空间存归并结果以及递归时深度为 $log2n$ 的栈空间, 所以其空间复杂度为 $O(n+logn)$</li></ul><p>是否稳定:</p><ul><li>在比较的时候是两两比较, 不存在跳跃, 因此稳定</li></ul><p>总之: 归并排序是一种比较占用内存, 并且效率高并且稳定的算法.</p><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>代码 TODO <code>Page 416</code></p><h3 id="9-9-快速排序-Quick-Sort"><a href="#9-9-快速排序-Quick-Sort" class="headerlink" title="9.9 快速排序 Quick Sort"></a>9.9 快速排序 Quick Sort</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWF4NDExVTd6az9mcm9tPXNlYXJjaCZzZWlkPTU4MDcxNDcyMTczMjE2MzA5NDM=">https://www.bilibili.com/video/BV1ax411U7zk?from=search&amp;seid=5807147217321630943<i class="fa fa-external-link-alt"></i></span></p><p>基本思想: 通过一趟排序将待排序记录分割成独立的两部分, 其中一部分记录的关键字均比另一部分的关键字小, 则可以对这两部分继续进行排序, 从而整个序列有序.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Quick Sort</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Qsort(L, <span class="number">1</span>, L-&gt;length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对顺序表 L 中的子序列 L-&gt;r[low..high] 进行快排</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QSort</span><span class="params">(SqList *L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pivot;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        pivot = Partition(L, low, high);</span><br><span class="line">        Qsort(L, low, pivot);</span><br><span class="line">        QSort(L, pivot + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 交换顺序表 L 字表中的记录, 使枢纽记录到位, 并返回其所在位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(SqList *L, <span class="type">int</span> low, <span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pivotkey;</span><br><span class="line">    pivotkey = L-&gt;r[low]; <span class="comment">// 子表的第一个记录作为枢纽记录</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high)  <span class="comment">// 从中间表向中间扫描</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivotkey)</span><br><span class="line">        &#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(L, low, high); <span class="comment">// 将比枢纽记录小的记录交换到低端</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey)</span><br><span class="line">            low++;</span><br><span class="line">        swap(L, low, high);  <span class="comment">// 将比枢纽记录大的记录交换到高端</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;  <span class="comment">// 返回枢纽所在的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-9-2-快速排序-时间复杂度"><a href="#9-9-2-快速排序-时间复杂度" class="headerlink" title="9.9.2 快速排序 时间复杂度"></a>9.9.2 快速排序 时间复杂度</h4><p>时间复杂度: $O(nlogn)$</p><p>空间复杂度: $O(nlogn)$</p><h4 id="9-9-3-优化"><a href="#9-9-3-优化" class="headerlink" title="9.9.3 优化"></a>9.9.3 优化</h4><ol><li>优化选取枢轴<ol><li>随机选取枢轴</li><li>三数取中: 取三个关键字进行排序, 将中间数作为枢纽, 一般去左端, 右端和中间三个数, 也可以随机选取</li><li>九数取中</li></ol></li><li>优化不必要的交换</li><li>优化最小数组时的排序方案</li><li>优化递归操作</li></ol><h3 id="9-10-总结回顾"><a href="#9-10-总结回顾" class="headerlink" title="9.10 总结回顾"></a>9.10 总结回顾</h3><p>分类:</p><ul><li>简单算法: 冒泡, 简单选择, 直接插入</li><li>改进算法: 希尔, 堆, 归并排序, 快排</li></ul><p>最后三种改进算法要胜过希尔排序, 并且远远超过前面三种简单算法.</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gez8oyrr09j31060bkn7h.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gez8xezy0mj30zl0u04qp.jpg"></p><hr><p>有用的链接：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3MudXNmY2EuZWR1L35nYWxsZXMvdmlzdWFsaXphdGlvbi9BbGdvcml0aG1zLmh0bWw=">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html<i class="fa fa-external-link-alt"></i></span> 算法可视化网站</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWF4NDExVTd6az9mcm9tPXNlYXJjaCZzZWlkPTU4MDcxNDcyMTczMjE2MzA5NDM=">【TED-ed】快速排序是什么【6小时字幕组】_哔哩哔哩_bilibili<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优秀的项目备忘</title>
      <link href="/articles/6d3e6a59.html"/>
      <url>/articles/6d3e6a59.html</url>
      
        <content type="html"><![CDATA[<h2 id="nginx-tutorial：Nginx-极简教程"><a href="#nginx-tutorial：Nginx-极简教程" class="headerlink" title="nginx-tutorial：Nginx 极简教程"></a>nginx-tutorial：Nginx 极简教程</h2><p>Github 地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2R1bnd1L25naW54LXR1dG9yaWFs">https://github.com/dunwu/nginx-tutorial<i class="fa fa-external-link-alt"></i></span></p><p>在线阅读：<span class="exturl" data-url="aHR0cHM6Ly9kdW53dS5naXRodWIuaW8vbmdpbngtdHV0b3JpYWwv">https://dunwu.github.io/nginx-tutorial/<i class="fa fa-external-link-alt"></i></span> 。</p><p>你可以配合《深入理解 Nginx（第 2 版）》 这本书食用。</p><h2 id="Guice：轻量级依赖注入框架"><a href="#Guice：轻量级依赖注入框架" class="headerlink" title="Guice：轻量级依赖注入框架"></a>Guice：轻量级依赖注入框架</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9ndWljZQ==">Guice<i class="fa fa-external-link-alt"></i></span> 是 Google 开源的一个轻量级依赖注入框架，相当于一个功能极简化的轻量级 Spring Boot。在某些情况下非常实用，就比如说我们的项目只需要使用依赖注入，不需要 AOP 等功能特性。</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9ndWljZS93aWtpL01vdGl2YXRpb24=">DI 的核心思想<i class="fa fa-external-link-alt"></i></span>:</p><blockquote><p>Like the factory, dependency injection is just a design pattern. The core principle is to separate behaviour from dependency resolution.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源项目 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
